\chapter{Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}{
  \label{ch:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}
  \input{macros/multigroup.tex}
  \input{macros/DiscreteOrdinates.tex}
  \input{macros/MOC.tex}
  \def\figpath{chapters/05/figures/}
  \graphicspath{ {\figpath} }

  \NewDocumentCommand{\modFunc}{}{\widehat{F}_2(\segopt)}

  The studies performed in this thesis have made extensive use of the \acf{LSA} introduced by \citet{Ferrer2016}.
  Through the use of the approximation, as presented in the original work, instabilities and inefficiencies were found.
  This chapter aims to present two improvements made to this approximation that have been a focus of this research: improved exponential tabulation \cite{Fitzgerald2018}, and an improved formulation for multi-physics and 2D/1D applications \cite{Fitzgerald2019}.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Exponential Tabulation
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Exponential Tabulation}{\label{sec:LSMOC:Exponential Tabulation}
    The original moment-based \ac{LSMOC} formulation \cite{Ferrer2016}, detailed in \cref{sec:MOC:LSA}, uses several exponential functions:
    \begin{subequations}\label[subeqs]{eqs:LSMOC:ET:Exponential Functions}
      \begin{equation}\label{eq:LSMOC:ET:F1}
        F_1(\opt) \defined 1 - e^{\opt},
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:F2}
        F_2(\opt) \defined 2\left[\opt - F_1(\opt)\right] - \segopt F_1(\opt),
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:G1}
        G_1(\segopt) \defined 1 + \frac{\segopt}{2} - \left(1 + \frac{1}{\segopt}\right)F_1(\segopt),
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:G2}
        G_2(\segopt) \defined \frac{2}{3}\segopt - \left(1 + \frac{2}{\segopt}\right)G_1(\segopt),
      \end{equation}
      and
      \begin{equation}\label{eq:LSMOC:ET:H}
        H(\segopt) \defined \frac{\segopt}{2} - G_1(\segopt),
      \end{equation}
    \end{subequations}
    where $\opt$ is the variable optical thickness, and $\segopt$ is the total optical thickness of a segment.
    Although the functions $F_1(\opt)$, and $F_2(\opt)$ are functions of variable $\opt$, in the implementation of this method in code they are only ever evaluated over the full optical thickness, $\segopt$.
    The functions, $G_1(\segopt)$, $G_2(\segopt)$, and $H(\segopt)$ all require special treatment around $\segopt = 0$, in this work this is handled via Taylor interpolation about $\segopt=0$.

    \begin{figure}
        \centering
        \includegraphics[width=0.90\linewidth]{exponentials/exponential-functions}
        \caption{The exponential functions, \cref{eqs:LSMOC:ET:Exponential Functions}, from 0 to 10.\label{fig:Exponential Functions}}
    \end{figure}

    These functions all involve an exponential, $e^{-\segopt}$; although this does not present a problem mathematically, the exponential function is a transcendental function that tends to be slow when evaluated computationally.
    For efficient transport codes, this presents a challenge.
    Previous works have demonstrated that function interpolation can provide significant run-time reduction \cite{Yamamoto2004}, and the original formulation \cite{Ferrer2016} suggested the use of function interpolation (though no details were provided).

    \subsection{First Approach: Improved Accuracy}{\label{ssec:LSMOC:ET:First Approach: Improved Accuracy}
      With the implementation of \ac{LSA} into MPACT, stability issues were observed in problems with very small transport cross sections, such as the fuel-clad gap in \acp{LWR}.
      These stability issues were only observed when exponential function interpolation was used, and the simplest method for addressing the issue was to increase the accuracy of the exponential interpolation.
      It was discovered that the root of the problem was the $F_2(\segopt)$ function in the transmission equation
      \begin{equation}\label{eq:LSMOC:ET:Transmission Original}
        \afluxout = \afluxin
                  + \left(\frac{\tsrcF}{\xst}-\afluxin\right)F_1(\segopt)
                  + \frac{\tsrcL}{2\left(\xst\right)^2}F_2(\segopt).
      \end{equation}
      In MPACT, source terms are actually computed and stored as $q/\xst$; however the $F_2(\segopt)$ term has an additional inverse $\xst$.
      In problems with near-void regions, where $\xst$ is small, any error in $F_2(\segopt)$ interpolation will be magnified.
      The simplest approach is to increase the accuracy of the exponential interpolation to account for the lowest expected cross sections; in the test problem this was on the order of $10^{-5}$.
      Thus, the expectation is that an interpolation 5 orders of magnitude more accurate than previous accuracy would be sufficient.
      Previous work \cite{Yamamoto2004} indicated that for \ac{FSMOC} calculations an max interpolation error of $10^{-7}$ was sufficient, i.e. for \ac{LSMOC} the max error would be within $10^{-12}$.

      Creating interpolation tables with the necessary accuracy for these problems requires some care.
      The original investigation of exponential interpolation for transport calculations  done by \citet{Yamamoto2004} indicated two methods of controlling interpolation accuracy.
      One method to increase interpolation accuracy is to increase the number of intervals (decreased interval width); however, this increased the memory.
      Alternatively, higher order polynomials can be used in the interpolation, which overall tends to reduce memory at the expense of increased run-times.

      In this investigation, two additional methods for controlling accuracy were investigated: interpolation node choice, and non-uniform interval widths.
      \subsubsection{Interpolation Points}{\label{sssec:ET:Interpolation Points}
        Within each interval of an interpolation table, the function is computed at interpolation points and an approximation of the function is made as the polynomial passing through these points.
        The placement of these points within each interval can greatly affect the accuracy of the approximation.
        Previous works \cite{Yamamoto2004,Kochunas2013} used evenly spaced interpolation points within each interval; however, this does not minimize the error in the approximation.
        An example is shown in \cref{fig:LSMOC:ET:Interpolation Example}.

        \begin{figure}
          \centering
          \includegraphics[width=0.90\linewidth]{exponentials/interpolation-example}
          \caption{Example of linear interpolation with uniform interval widths and interpolation points on the edge of the domain.\label{fig:LSMOC:ET:Interpolation Example}}
        \end{figure}

        Let $P_n(x)$ be the order $n$ polynomial approximating a function, $f(x)$, on an arbitrary interval $[a,b]$.
        The maximum error, $\epsilon$, within an interval is given by
        \begin{equation}\label{eq:LSMOC:ET:Interpolation Error}
          \epsilon = \frac{1}{(n+1)!}\left(\max_{\xi\in[a,b]}\lrabs{f^{(n+1)}(\xi)}\right)\left(\max_{x\in[a,b]}\lrabs{\prodl[j=1][n+1](x-x_j)}\right),
        \end{equation}
        for some value $\xi\in[a,b]$, where $f^{(n+1)}$ is the $n+1$-th derivative of $f(x)$.
        The choice of interpolation points will only affect the last term enclosed in parentheses.

        The Chebyshev points \cite{Stewart1996} are a set of values in $[a,b]$ that minimize $\max_{x\in[a,b]}\lrabs{\prodl[j=1][n+1](x-x_j)}$, and are given by
        \begin{equation}\label{eq:LSMOC:ET:Chebyshev Points}
          x_k = \frac{1}{2}\left[(a+b)+(b-1)\cos\left(\frac{2k-1}{2(n+1)}\pi\right)\right], \forall k\in\{1,2,...,n,n+1\}.
        \end{equation}
        By using the Chebyshev points, the maximum interpolation error, $\epsilon$, can be simplified to
        \begin{equation}\label{eq:LSMOC:ET:Chebyshev Interpolation Error}
          \epsilon = \frac{1}{2^n(n+1)!}\left(\frac{b-a}{2}\right)^{n+1}\max_{\xi\in[a,b]}\lrabs{f^{(n+1)}(\xi)}.
        \end{equation}
        Because the Chebyshev points do not include the end-points of the interval, there is additional cost in setting up the interpolation table, but this is negligible to typical \ac{MOC} calculation times.
        An interpolation table using Chebyshev points \emph{reduces error at no run-time cost} compared to a table using evenly spaced points.
        For this reason, Chebyshev points will be assumed for the remainder of this section.
        \Cref{tab:LSMOC:ET:Chebyshev Error} shows maximum errors for $F_1(\opt)$ interpolation for uniformly spaced points and Chebyshev points for an interval width $\Delta=b-a$.
        \begin{table}
          \centering
          \renewcommand{\arraystretch}{1.45}
          \caption{Maximum error in $F_1(\opt)$ for interval width $\Delta$.}
          \label{tab:LSMOC:ET:Chebyshev Error}
          \begin{tabular}{@{}ccc@{}}\toprule
            Polynomial Order & Uniform points   & Chebyshev points\\\midrule
            1                & $\frac{\Delta^2}{8}$           & $\frac{\Delta^2}{16}$\\
            2                & $\frac{\Delta^3}{72\sqrt{3}}$  & $\frac{\Delta^3}{192}$\\
            3                & $\frac{\Delta^4}{1536}$        & $\frac{\Delta^4}{3072}$\\\bottomrule
          \end{tabular}
        \end{table}
      }
      \subsubsection{Interval Width}{\label{sssec:LSMOC:ET:Interval Width}
        The conventional approach for interpolation tables has been to use a constant interval width, $\Delta$, for all intervals in the domain.
        This interval width is then used to control the error of the table.
        \Cref{eq:LSMOC:ET:Interpolation Error} shows that the interval bounds affect the interpolation error through the derivative term.
        The second and higher order derivatives of each of the exponential functions (\cref{eqs:LSMOC:ET:Exponential Functions}) approach zero as $\segopt$ approaches infinity.
        This indicates that the interpolation error typically decreases as the optical thickness increases in the conventional approach.

        However, is is possible to maintain the same maximum error over each interval if a variable interval width, $\Delta_i$, is used, where $i$ indicates the interval index.
        By using a variable interval width, a table can use fewer intervals while maintaining the same maximum error.
        However, since the widths are no longer constant, there is no longer a simple/direct conversion from $\segopt$ to $i$.
        Although there may be better ways, for this work the smallest interval is used to break up the domain into a map which points to the correct interval for that range of values.

        It was found that the use of non-uniform interval widths allowed for significantly fewer total intervals, reducing the memory usage, but incurring overhead for the additional mapping to index.
        \Cref{fig:LSMOC:ET:Memory Analysis} shows the memory usage for a polar-independent interpolation table for $F_1(\segopt)$.
        Using a non-uniform table typically decreases the memory usage by nearly an order of magnitude.
        For polar-dependent tables, the memory usage will be multiplied by the largest inverse sine of the polar angle, and the number of polar angles.

        \begin{figure}
          \centering
          \includegraphics[width=0.90\linewidth]{exponentials/MemoryAnalysis}
          \caption{The memory usage of a single interpolation table (polar independent) for $F_1(\segopt)$ is shown as a function of the maximum error for different interpolation orders and tabulation methods.\label{fig:LSMOC:ET:Memory Analysis}}
        \end{figure}

        Because all the functions of \cref{eqs:LSMOC:ET:Exponential Functions} are related, it is possible to tabulate only a single function and compute the others from the resulting interpolated value.
        However, if $F_1(\segopt)$ is known accurately, it is not possible to compute $H(\segopt)$ for very small $\segopt$ due to round-off errors.
        Instead one can tabulate $H(\segopt)$ and use the result to compute the other functions; however, this may incur more error than directly interpolating these functions.
      }
    }
    \subsection{Function Modification}{\label{ssec:LSMOC:ET:Function Modification}
      A second approach for addressing the instability due to inaccurate function interpolation was taken: change the functions.
      Recall that the highly accurate interpolation tables of \cref{ssec:LSMOC:ET:First Approach: Improved Accuracy} were necessary due to the inverse total (or transport) cross section on the $F_2(\segopt)$ term of \cref{eq:LSMOC:ET:Transmission Original}.
      Manipulating this term, we define a new function
      \begin{equation}\label{eq:LSMOC:ET:F2 Modified Definition}
        \frac{F_2(\segopt)}{\xst} = \nlen\modFunc,
      \end{equation}
      where
      \begin{equation}\label{eq:LSMOC:ET:F2 Modified}
        \modFunc \defined 2\left(1-\frac{F_1(\segopt)}{\segopt}\right) - F_1(\segopt).
      \end{equation}
      The $\modFunc$ function can be tabulated in place of $F_2(\segopt)$; this will require an additional multiplication by the segment length $\nsegl$ causing slight reduction in performance.
      But, by using the modified $\modFunc$ function, the underlying cause of the numerical instability is addressed, and the more accurate interpolation is no longer necessary.

      One approach is to tabulate the $\modFunc$ function in place of the $F_2(\segopt)$ function, and multiply by $\nsegl$ during evaluation.
      However, as stated in the previous section, it is possible to tabulate a single function and compute the others.
      The $H(\segopt)$ function could be tabulated again; but tabulating an intermediate function,
      \begin{equation}\label{eq:LSMOC:ET:E1}
        E_1(\segopt) \defined \frac{1-e^{-\segopt}}{\segopt},
      \end{equation}
      uses the same number of operations to compute the other functions.
      This $E_1(\segopt)$ function also has smaller derivative terms around $\segopt=0$, allowing for larger interval widths with no loss in accuracy.
      Therefore, it is expected that $E_1(\segopt)$ tabulation will be more efficient.
    }
    \subsection{Results}{\label{ssec:LSMOC:ET:Results}
      The results of this section were generated in serial on a Linux system with an Intel Xeon E3-1241 v3 (3.50 GHz) processors with 8 MB L3 cache.
      Results were generated for a 2-D \ac{MOC} transport calculation.
      In 2-D it is sometimes convenient to store separate interpolation tables for each polar angle.
      Both polar dependent and independent tables were tested.

      In both of the results sections, results were generated using tables for the three functions ($F_1(\segopt)$, $F_2(\segopt)$, $H(\segopt)$), or a single function (which is then used to compute the others).
      In the results, it is considered 3 functions, as the $G_1(\segopt)$, and $G_2(\segopt)$ functions are only used in pre-computing coefficients, and not in the main \ac{MOC} solver routine.

      \subsubsection{Results using More Accurate Tables}{\label{sssec:LSMOC:ET:Results using More Accurate Tables}
        \Cref{tab:LSMOC:ET:Naive Results} shows results for the different interpolation methods in a 2-D \ac{MOC} calculation.
        The use of non-uniform intervals significantly reduced the memory usage, but the run-times generally increased.
        This is likely due to the overhead from the additional index mapping operation; it is possible that a more efficient index mapping would change these results.

        The linear tables were significantly slower than higher-order interpolations, and the non-uniform linear tables were actually slower than just using the builtin transcendental functions.
        The poor performance is due to the main memory accesses caused by the table size exceeding the largest (L3) cache size.
        The polar independent tables were faster only in the case of the linear tables, due primarily to the reduction in memory.
        In all other cases the polar-dependent tables were able to more efficiently approximate the functions.
        Using either second or third order tables gave reasonably low run-times; compared to the analytic evaluations the order 2 uniform polar dependent table led to $\sim 3.5$x speed-up in the exponential time, and $\sim 1.9$x speed-up in the overall \ac{MOC} run-time.
        The results for both second and third order interpolation tables did not vary significantly, the second order was slightly faster for uniform tables.

        However, if a single function is tabulated and used to compute the others, the memory footprint of the interpolation tables can be significantly reduced.
        Moreover, the memory accesses are reduced in favor of floating point operations which increases the computational intensity and temporal cache locality of the implementation.
        Generally, this is a favorable strategy for improving code performance as a memory access is expected to take \emph{at minimum} the same time as a single \ac{FLOP}, with cache-misses increasing that time.
        Indeed, \cref{tab:LSMOC:ET:Naive Results} shows that tabulating the single function reduced run-time in all cases.

        \begin{table}
          \centering
          \caption{Results for different exponential function evaluation methods. Maximum interpolation error of $10^{-12}$. ``w/ pol'' indicates a table with polar dependence, and ``w/o pol'' indicates a table without polar dependence.}
          \label{tab:LSMOC:ET:Naive Results}
          \footnotesize
          \begin{tabular}{@{}ccrrrrrrrrr@{}}\toprule
            Method & Table Type & Order & \multicolumn{2}{c}{\shortstack[c]{Exponential\\Time (s)}} & & \multicolumn{2}{c}{\ac{MOC} Time (s)} && \multicolumn{2}{c}{Intervals (Memory)}\\\cmidrule{4-5}\cmidrule{7-8}\cmidrule{10-11}
                  &            &       & w/ pol & w/o pol & \phantom{}                           & w/ pol & w/o pol & \phantom{}  &  \multicolumn{1}{c}{w/ pol} & \multicolumn{1}{c}{w/o pol}\\\midrule
            Analytic & N/A & N/A & \multicolumn{2}{c}{432.5} && \multicolumn{2}{c}{654.7} && \multicolumn{2}{c}{N/A}\\\midrule
            \multirow{6}{*}{3-Functions}     & \multirow{3}{*}{Uniform}        & 1 & 382.6 & 360.3 && 622.5 & 591.0 && 6.00E7 (8.04 GB) & 1.00E7 (458 MB) \\\addlinespace[-0.2em]
                                                                              && 2 & 121.3 & 151.7 && 343.2 & 372.1 && 416080 (85.7 MB) & 69360  (4.8 MB) \\\addlinespace[-0.2em]
                                                                              && 3 & 124.1 & 169.0 && 347.5 & 388.7 && 32280  (9079 KB) & 5400   (506 KB) \\\cmidrule{2-11}\addlinespace[-0.2em]
                                                & \multirow{3}{*}{Non-Uniform} & 1 & 592.9 & 559.2 && 825.8 & 800.6 && 4.07E6  (878 MB) & 840658 (76.6 MB)\\\addlinespace[-0.2em]
                                                                              && 2 & 144.6 & 178.5 && 364.3 & 397.8 && 45265  (10.9 MB) & 8020    (835 KB)\\\addlinespace[-0.2em]
                                                                              && 3 & 139.6 & 199.8 && 358.5 & 420.0 && 4491    (1.4 MB) & 796    (85.2 KB)\\\midrule
            \multirow{6}{*}{1-Function}       & \multirow{3}{*}{Uniform}       & 1 & 296.2 & 259.3 && 523.9 & 484.5 && 6.00E7 (2.68 GB) & 1.00E7  (153 MB)\\\addlinespace[-0.2em]
                                                                              && 2 &  91.4 & 123.2 && 310.2 & 345.7 && 416080 (28.6 MB) & 69360  (1.59 MB)\\\addlinespace[-0.2em]
                                                                              && 3 &  87.2 & 133.2 && 305.4 & 353.6 && 32280  (2.96 MB) & 5400    (169 KB)\\\cmidrule{2-11}\addlinespace[-0.2em]
                                                & \multirow{3}{*}{Non-Uniform} & 1 & 474.6 & 424.0 && 714.6 & 653.9 && 4.07E6  (415 MB) & 722899 (49.2 MB)\\\addlinespace[-0.2em]
                                                                              && 2 & 105.8 & 146.4 && 326.6 & 367.7 && 41444   (4.4 MB) & 7338   (443  KB)\\\addlinespace[-0.2em]
                                                                              && 3 &  98.9 & 153.3 && 318.8 & 373.2 && 4152    (515 KB) & 735    (33.5 KB)\\\bottomrule
          \end{tabular}
        \end{table}
      }
      \subsubsection{Results using Modified Function}{\label{sssec:LSMOC:ET:Results using Modified Function}
        Results were generated for the same cases as the more accurate table, but the interpolation accuracy was $10^{-7}$ rather than $10^{-12}$, as the function modification addressed the cause of the instability.
        The results are summarized in \cref{tab:LSMOC:ET:Final Results}.
        In one approach the three functions are tabulated, in the other $E_1(\segopt)$ is tabulated and used to compute the three functions.
        Previous results showed that the polar-independent and non-uniform interval width tables were slower than uniform polar-dependent tables; here the results are only shown for the uniform polar-dependent interpolation tables.

        The interpolation accuracy is not required to be as high as in the previous cases, thus the tables are significantly smaller in memory size.
        The linear tables no longer exceed the L3 cache size and are not prohibitively slow to use.
        In fact, the linear tables are the fastest option for both 3-table and single-table interpolation methods.
        Interpolating $E_1(\segopt)$ and computing the other functions from the result was the fastest approach overall.
        As before, this is expected because this method favors \acp{FLOP} over memory accesses.

        This approach also significantly reduces the number of intervals necessary (by about 3 orders of magnitude).
        Although the higher-order interpolation ended up not being more efficient than the linear interpolation tables, the number of intervals is extremely small.
        These methods may be useful on different architectures (such as \acp{GPGPU}\footnote{this statement was not confirmed as part of this study, and is speculation based on knowledge of architecture constraints.}) where memory is more limited than on a single-threaded \ac{CPU} calculation.

        \begin{table}
          \centering
          \caption{Results using the modified $\modFunc$ function, with maximum interpolation error of $10^{-7}$. Memory is under 1 MB in all cases.}
          \label{tab:LSMOC:ET:Final Results}
          \begin{tabular}{@{}ccccc@{}}\toprule
            Method & Order & Exp.     & \ac{MOC}& \# Intervals \\
                   &       & Time (s) & Time (s) & \\\midrule
            \multirow{3}{*}{3-Functions}      & 1 &  88.4 & 307.9 & 4774\\
                                              & 2 &  99.7 & 316.8 &  225\\
                                              & 3 & 116.5 & 333.1 &   46\\\midrule
            \multirow{3}{*}{$E_1(\opt)$ Only} & 1 &  80.5 & 299.0 & 2739\\
                                              & 2 &  87.6 & 307.3 &  158\\
                                              & 3 &  99.0 & 317.7 &   38\\\bottomrule
          \end{tabular}
        \end{table}
      }
    }
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Conclusions
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Conclusions}{\label{ssec:LSMOC:ET:Conclusions}
      This study focused on the investigation of efficient approximation of the exponential functions in the \ac{LSMOC}.
      Methods for efficiently approximating the exponential function for \ac{FSMOC} have previously been investigated.
      However, these methods, applied without modification to the \ac{LSMOC} can lead to numerical instability in problems with near-void regions.
      One approach to deal with these instabilities is to improve the accuracy of the interpolation tables based on the lowest cross section in the problem.
      While this approach can be made efficient, if cross sections become too small the tables may become exceedingly large and significantly hamper performance.

      This investigation revealed that the cause of the instability was the $F_2(\segopt)$ function in the transmission equation.
      By instead manipulating the term including this function, the cause of the instabilities can be addressed.
      This approach no longer requires excessively large interpolation tables; however, some key-findings from the first approach can be applied to make this appraoch faster.
      First, the use of Chebyshev points significantly increases interpolation accuracy for the same number of intervals as uniformly spaced points, at no run-time cost.
      Additionally, by interpolating a single function and using the result to compute the other functions performance can be significantly improved.
    }
  }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Improved Linear Source Formulation for Multi-physics and 2D/1D Applications
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}{\label{sec:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}
    As stated in \cref{sec:MOC:LSA}, the original derivation of the moment-based \acf{LSA} from \citet{Ferrer2016} faced inefficiencies in problems with non-constant cross sections.
    The inefficiencies arose from the use of pre-computed coefficients, \cref{eq:MOC:LSA:C Matrix}, which must be re-computed if cross sections change.
    In multiphysics calculations, such as with \ac{TH} feedback, cross sections typically change each iteration, leading to significant overhead from re-computing these terms.
    This section presents and equivalent formulation, which eliminates the need to re-compute these terms if cross sections change, without additional operations.

    \subsection{Derivation}{\label{ssec:LSMOC:Derivation}
      The derivation of this improved formulation begins with the same initial steps as the derivation detailed in \cref{ssec:MOC:LSA:Derivation}.
      Several of these equations are repeated in this section for clarity.
      The source is assumed to have a spatially linear shape
      \begin{equation}\label{eq:LSMOC:Source Shape}
        \source[mi][g][\loc] \approx \srcF[mi] + \loc\vdot\srcL[][mi],
      \end{equation}
      and the angular flux moments can be expanded similarly
      \begin{equation}\label{eq:LSMOC:Flux Expansion}
        \fluxA(\loc) = \fluxF + \loc\vdot\fluxL.
      \end{equation}
      The source can be computed from the flux moments using \cref{eq:MOC:LSA:Linear Source Computation}.

      Computing the source requires the flux to be evaluated during transport sweeping.
      The angular flux moments are given by \cref{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions}, but are repeated here for clarity.
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Region-Averaged Flux Moments Definitions}
        The spatially flat angular flux moments are defined by integrating the flux multiplied by a spherical harmonics moment function over space and directions,
        \begin{equation}\label{eq:LSMOC:Region-Averaged Flux Moment Definition}
            \fluxF \defined \MOCIntegral{\SH \aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\MOCTrackIntegral{\aflux[][g][]}.
        \end{equation}
        To determine the spatial expansion coefficients of the flux moments, \cref{eq:LSMOC:Flux Expansion} is operated on by $\MOCIntegral{\SH\loc(\vdot)}$.
        As before, this should be directly proportional to the angular flux operated on by $\MOCIntegral{\SH\loc\aflux[][g][]}$, a system of equations is found
        \begin{equation}\label{eq:LSMOC:Moment to Expansion Coefficient}
            \M\fluxL = \MOCIntegral{\SH\loc\aflux[][g][]},
        \end{equation}
        where
        \begin{equation}\label{eq:LSMOC:Geometric Moments}
            \M \defined \MOCIntegral{\loc^T\loc}.
        \end{equation}
        The spatial angular flux moments, $\MOCIntegral{\SH\loc\aflux[][g][]}$, are then defined as
        \begin{equation}\label{eq:LSMOC:Region-Averaged Spatial Angular Flux Moments Definition}
            \MOCIntegral{\SH\loc\aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\left(\locIn\MOCTrackIntegral{\aflux[][g][]} + \dirm\MOCTrackIntegral{\nlen\aflux[][g][]} / \renorm[mi]\right).
        \end{equation}
      \end{subequations}

      With the assumed source shape, \cref{eq:LSMOC:Source Shape}, the characteristic transport equation becomes
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Characteristic Form}
        The characteristic transport equation becomes
        \begin{equation}\label{eq:LSMOC:Characteristic Form}
          \left[\deriv{}{\nlen} + \xst\right]\aflux = \tsrcF + \tsrcL\left(\nlen - \frac{\nsegl}{2}\right),
        \end{equation}
        where
        \begin{equation}\label{eq:LSMOC:Track Average Source}
          \tsrcF \defined \rfourpi\left[\srcF[mi] + \locCent \vdot \srcL[][mi]\right],
        \end{equation}
        \begin{equation}\label{eq:LSMOC:Track Linear Source}
          \tsrcL \defined \rfourpi\left[\frac{\dirm\vdot\srcL[][mi]}{\renorm[mi]}\right],
        \end{equation}
        and $\locCent$ is the local-coordinate centroid of the track-segment.
      \end{subequations}
      Substituting this assumed source shape (linear) into the generic \ac{MOC} solution, given by \cref{eq:MOC:MOC Generic Solution}, the angular flux along a track-segment is found to be
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Angular Flux Solution}
          \begin{equation}\label{eq:LSMOC:Angular Flux Solution}
              \aflux = \afluxin + \left(\frac{\tsrcF}{\xst} - \afluxin\right)F_1(\opt) + \frac{\tsrcL}{2(\xst)^2}F_2(\opt),
          \end{equation}
          where
          \begin{equation}\label{eq:LSMOC:F1}
              F_1(\opt) \defined 1 - \exp(-\opt),
          \end{equation}
          and
          \begin{equation}\label{eq:LSMOC:F2}
              F_2(\opt) \defined 2[\opt-F_1(\opt)] - \segopt F_1(\opt).
          \end{equation}
      \end{subequations}

      To evaluate the moments defined in \cref{eqs:LSMOC:Region-Averaged Flux Moments Definitions}, the track-average flux and first spatial moment of the angular flux must be determined.
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Flux Track Moments}
        The track-average flux is determined as it was before, by operating on \cref{eq:LSMOC:Characteristic Form} by $\nsegl\MOCTrackIntegral{(\vdot)}$, yielding
        \begin{equation}\label{eq:LSMOC:0th Track Moment of the Flux}
          \MOCTrackIntegral{\aflux[][g][]} = \frac{\tsrcF}{\xst} + \frac{\dflux}{\segopt}.
        \end{equation}
        At this point the two derivations diverge from one another.
        In the previous formulation, the integral in $\MOCTrackIntegral{\nlen\aflux[][g][]}$ is \emph{explicitly} evaluated by substituting in the solution of the angular flux along the track (\cref{eqs:MOC:LSA:Angular Flux Solution}).
        Here, the moment will be found implicitly by operating on \cref{eq:LSMOC:Characteristic Form} by $\nsegl\MOCTrackIntegral{\nlen(\vdot)}$, just as was done for the 0th moment.
        This results in
        \begin{equation}\label{eq:LSMOC:1st Track Moment of the Flux}
          \MOCTrackIntegral{\nlen\aflux[][g][]} =
            \frac{\MOCTrackIntegral{\aflux[][g][]} - \afluxout}{\xst}
              + \frac{\nsegl}{2}\left[\frac{\tsrcF}{\xst}
              + \frac{\tsrcL}{\xst}\frac{\nsegl}{6}\right].
        \end{equation}
        Unlike \cref{eq:MOC:LSA:Track-Averaged Linear Angular Flux}, there a not any new exponential functions introduced in this form.
      \end{subequations}

      Previously, the average track flux, $\MOCTrackIntegral{\aflux[][g][]}$, was expanded to find a simpler final form.
      This is the case here as well; however, the out-going flux, $\afluxout$, will not be expanded, as this must necessarily be computed during transmission.
      \Cref{eqs:LSMOC:Region-Averaged Flux Moments Definitions} can be simplified into
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Region-Averaged Flux Moments}
        \begin{equation}\label{eq:LSMOC:Region-Averaged Flat Flux Moments}
          \fluxF = \frac{\fourpi}{V_i\xst}\suml[m]\wt\SH\suml[k]\tA\left(\nsegl\tsrcF + \dflux\right),
        \end{equation}
        and
        \begin{aequation}\label{eq:LSMOC:Region-Averaged Linear Flux Moments}
          \MOCIntegral{\SH\loc\aflux[][g][]}
            = &\frac{1}{V_i}\suml[m]\wt\SH\suml[k]\tA\nsegl\left[\locCent\srcF + \left(\locCent(\locCent)^T + \frac{\segl^2}{12}\dirm\dirm^T\right)\srcL\right]\\
            + &\frac{\fourpi}{V_i\xst}\suml[m]\wt\SH\suml[k]\tA\left[\locIn\dflux + \dirm\segl\left(\frac{\dflux}{\segopt}-\afluxout+\frac{\tsrcF}{\xst}\right)\right]
        \end{aequation}
      \end{subequations}

      \Cref{eq:LSMOC:Region-Averaged Linear Flux Moments} contains $\dflux/\segopt$ terms, rather than only $\dflux$ terms.
      For numerical stability, it is beneficial to compute this quantity directly, rather than $\dflux$ and performing division.
      This can be found by evaluating the transmission equation, \cref{eq:LSMOC:Angular Flux Solution}, giving
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Average Slope}
        \begin{equation}\label{eq:LSMOC:Average Slope}
          \frac{\dflux}{\segopt} = \left(\afluxin-\frac{\tsrcF}{\xst}\right)E_1(\segopt) - \frac{\nsegl}{2}\frac{\tsrcL}{\xst}T_2(\segopt),
            \end{equation}
            where
            \begin{equation}\label{eq:LSMOC:E1}
                E_1(\segopt) \defined \frac{F_1(\segopt)}{\segopt},
            \end{equation}
            \begin{equation}\label{eq:LSMOC:T2}
                T_2(\segopt) \defined 2E_2(\segopt) - E_1(\segopt),
            \end{equation}
            and
            \begin{equation}\label{eq:LSMOC:E2}
                E_2(\segopt) \defined \frac{1-E_1(\segopt)}{\segopt}.
            \end{equation}
      \end{subequations}
      Here, $E_2(\segopt)$ is defined as an intermediate function which has smaller derivative terms, meaning higher accuracy with fewer interpolation intervals (see \cref{sec:LSMOC:Exponential Tabulation}).
      Following the conclusions of \cref{sec:LSMOC:Exponential Tabulation}, only the $E_2(\segopt)$ function needs to be tabulated, and then is used to compute the other two exponential functions, $E_1(\segopt)$, and $T_2(\segopt)$.
      The outgoing flux can then be evaluated as
      \begin{equation}\label{eq:LSMOC:Outgoing Flux}
        \afluxout = \afluxin - \segopt\frac{\dflux}{\segopt}.
      \end{equation}
    }
    \subsection{Particle Conservation}{\label{ssec:LSMOC:Particle Conservation}
      As described in \cref{ssec:MOC:LSA:Particle Conservation}, particle conservation puts the constraint of using direction-dependent renormalization and centroids, in addition to directional quadrature constraints.
      If these constraints are satisfied, \cref{eqs:LSMOC:Region-Averaged Flux Moments} can be simplified into
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Region-Averaged Flux Moments}
        \begin{equation}\label{eq:LSMOC:Region-Averaged Flat Flux Moments}
          \fluxF = \suml[m]\wt\SH\frac{\srcF}{\xst} + \frac{\fourpi}{V_i\xst}\suml[m]\wt\SH\suml[k]\tA\dflux,
        \end{equation}
        and
        \begin{aequation}\label{eq:LSMOC:Region-Averaged Linear Flux Moments}
          \MOCIntegral{\SH\loc\aflux[][g][]} =
            &\suml[m]\wt\SH\M[][mi]\frac{\srcL}{\xst}\\
            +& \frac{\fourpi}{V_i\xst}\suml[m]\wt\SH\suml[k]\tA\left[\locIn\dflux + \dirm\segl\left(\frac{\dflux}{\segopt}-\afluxout+\frac{\tsrcF}{\xst}\right)\right],
        \end{aequation}
        where
        \begin{equation}\label{eq:LSMOC:Direction-Dependent M}
          \M[][mi] \defined \frac{1}{V_i}\suml[k]\tA\left[\locCent(\locCent)^T+\frac{\segl^2}{12}\dirm\dirm^T\right].
        \end{equation}
      \end{subequations}

      Although the above form seems to more computationally efficient, it would be negligent for this chapter to not include a more mathematically elegant form of \cref{eq:LSMOC:Region-Averaged Linear Flux Moments}.
      The terms in the second summation may be rewritten as
      \begin{subequations}\label[subeqs]{eqs:LSMOC:Region-Averaged Linear Flux Moments Elegant}
        \begin{aequation}\label{eq:LSMOC:Region-Averaged Linear Flux Moments Elegant}
          \MOCIntegral{\SH\loc\aflux[][g][]} =&
            \suml[m]\wt\SH\M[][mi]\frac{\srcL}{\xst} \\
            &+ \frac{\fourpi}{V_i}\suml[m]\wt\SH\suml[k]\tA\left[\locIn\left(\afluxin-\tfluxF\right)-\locOut\left(\afluxout-\tfluxF\right)\right],
        \end{aequation}
        where $\tfluxF$ is the average track flux,
        \begin{equation}\label{eq:Average Track Flux}
          \tfluxF \defined \nsegl\MOCTrackIntegral{\aflux[][g][]}.
        \end{equation}
      \end{subequations}
      In this form, the interior summation over track-segments becomes a spatially weighted summation of the incident and outlet flux differences from the average flux.
    }
    \subsection{Isotropic Simplifications}{\label{ssec:LSMOC:Isotropic Simplifications}
      If the so called \acf{LIFA} scheme is used, the spatially flat moment equations do not change; however, \cref{eq:LSMOC:Region-Averaged Linear Flux Moments} can be simplified to
      \begin{aequation}\label{eq:LSMOC:LIFA:Region-Averaged Linear Flux Moments}
        \MOCIntegral{\SH\loc\aflux[][g][]} &= \M\frac{\srcL}{\xst}\\ &+ \frac{\fourpi}{V_i\xst}\suml[m]\wt\suml[k]\tA\left[\locIn\dflux+\dirm\segl\left(\frac{\dflux}{\segopt}-\afluxout+\frac{\tsrcF}{\xst}\right)\right]
      \end{aequation}
    }
    \subsection{Results}{\label{ssec:LSMOC:Results}
      \subsubsection{C5G7 Benchmark}{\label{sssec:LSMOC:C5G7 Benchmark}
        [C5G7 2-D Benchmark problem results]
      }
      \subsubsection{Typical Pin Cell Depletion}{\label{sssec:LSMOC:Typical Pin Cell Depletion}
        In order to evaluate the benefits of this new formulation, the first multiphysics case studied was a typical \ac{UO2} fuel cell, as specified by \ac{VERA} progression problem 1a \cite{VERAProblems}.
        Isotopic depletion calculations were run up to 70 \ac{GWDMT} ($\sim$1820 \ac{EFPD}) as \ac{HFP} conditions.
        Using the current default meshing parameters in MPACT as a starting point, various mesh parameters were coarsened to study their affect when using the \ac{LSMOC}.
        These cases were compared against a reference case which was very finely meshed with fine ray-spacing (0.001 cm), and a Tabuchi-Yamamoto \cite{Yamamoto2005} quadrature using 128 azimuthal angles and 4 polar angles over $\fourpi$
        All other cases were run using a Tabuchi-Yamamoto quadrature with 64 azimuthal angles and 4 polar angles, with a uniform ray-spacing of 0.05 cm.

        \paragraph{Default Mesh}{
          MPACT's current default meshing parameters were used as a starting point.
          Flat and linear source calculations were run on this mesh, to set a baseline for ``acceptable'' levels of error in the eigenvalue.
          Compared to the reference case, the \ac{LS} calculation had a larger maximum error in eigenvalue of 89.2 \ac{pcm}, whereas the \ac{FS} calculation had a maximum error of 65.5 \ac{pcm}.
          However, the average errors over the depletion were approximately the same: 31.6 and 33.7 \ac{pcm}, for the \ac{FS} and \ac{LS} calculations, respectively.
          The eigenvalue differences over the depletion calculation are shown in \cref{fig:LSMOC:1a:DefaultMesh:Eigenvalue}.
          The goal in this mesh refinement study is to determine acceptable meshing parameters without worse maximum or average eigenvalue errors.

          \begin{figure}
              \centering
              \includegraphics[width=\linewidth]{1a/DefaultMesh-Eigenvalues}
              \caption{Reference eigenvalues and differences for the default mesh pin cell case with isotopic depletion. \label{fig:LSMOC:1a:DefaultMesh:Eigenvalue}}
          \end{figure}
        }
        \paragraph{Fuel Radius}{
          During isotopic depletion, it is important to accurately capture the radial distribution of Plutonium, due to self-shielding effects.
          Plutonium is primarily produced in the outer rim of the pin, this is well known as the rim-effect.
          The default mesh uses three equal volume rings in the fuel region; however, we expect that two rings will be sufficient, when using the \ac{LSA}, if the extra ring is placed in such a way that it captures this rim-effect.
          Experimental studies of the rim-effect \cite{Lassmann1994} have found that there is a sharp rise in Plutonium at around between 80-90\% of the outer radius of the fuel.

          A series of calculations were run using two fuel rings with varying inner radius.
          The eigenvalue and Plutonium comparisons are shown in \cref{fig:LSMOC:1a:FuelRadius:Eigenvalue,fig:LSMOC:1a:FuelRadius:Pu239}.
          Comparing eigenvalues, a fractional radius between .825 and 0.875 seem to have little effect on the mean or worst-case eigenvalue difference.
          By comparing the concentration of Pu-239, these radii are again shown to be the most accurate; a fractional radius of 0.875 was chosen to be sufficient, and used in the remainder of the studies.

          \begin{figure}
              \centering
              \includegraphics[width=\linewidth]{1a/FuelRadius-Eigenvalues}
              \caption{Eigenvalue comparisons for problem 1a using various inner fuel radii. \label{fig:LSMOC:1a:FuelRadius:Eigenvalue}}
          \end{figure}
          \begin{figure}
            \centering
            \includegraphics[width=\linewidth]{1a/FuelRadius-Pu239}
            \caption{Pu-239 concentration comparisons for problem 1a using various inner fuel radii. \label{fig:LSMOC:1a:FuelRadius:Pu239}}
          \end{figure}
        }
        \paragraph{Moderator Ring and Azimuthal Divisions} {
          The remaining mesh parameters are the azimuthal divisions in the fuel, clad, gap, and moderator regions, and the presence of an additional surrounding ring of moderator.
          While it may be sufficient to use a single azimuthal division in some regions in larger cases, due to symmetry of this single pin case, using a single azimuthal region would cause the linear components of the source to be zero (i.e. it is equivalent to the \ac{FSA}).
          It was found that the coarsening of these parameters have an insignificant affect on the resulting eigenvalue when using the \ac{LSA}, with less than 1 \ac{pcm} difference over the entire depletion.
          Thus, four azimuthal divisions in each material region, and no additional surrounding moderator ring was found to be sufficiently accurate in this case.
        }
      }
      \subsubsection{2-D Lattices}{\label{sssec:LSMOC:2-D Lattices}
        [Lattice Cases]
      }
      \subsubsection{Assembly with Feedback}{\label{sssec:LSMOC:Assembly with Feedback}
        [Problem 6]
      }
      \subsubsection{Core Depletion with Feedback}{\label{sssec:LSMOC:Core Depletion with Feedback}
        [Problem 9]
      }
    }
  }

  % References
  \printbibliography
}