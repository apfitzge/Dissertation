\chapter{Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}{
  \label{ch:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}
  \input{macros/multigroup.tex}
  \input{macros/DiscreteOrdinates.tex}
  \input{macros/MOC.tex}
  \def\figpath{chapters/05/figures/}
  \graphicspath{ {\figpath} }

  \NewDocumentCommand{\modFunc}{}{\widehat{F}_2(\segopt)}

  The studies performed in this thesis have made extensive use of the \acf{LSA} introduced by \citet{Ferrer2016}.
  Through the use of the approximation, as presented in the original work, instabilities and inefficiencies were found.
  This chapter aims to present two improvements made to this approximation that have been a focus of this research: improved exponential tabulation \cite{Fitzgerald2018}, and an improved formulation for multi-physics and 2D/1D applications \cite{Fitzgerald2019}.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Exponential Tabulation
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Exponential Tabulation}{\label{sec:LSMOC:Exponential Tabulation}
    The original moment-based \ac{LSMOC} formulation \cite{Ferrer2016}, detailed in \cref{sec:MOC:LSA}, uses several exponential functions:
    \begin{subequations}\label{eqs:LSMOC:ET:Exponential Functions}
      \begin{equation}\label{eq:LSMOC:ET:F1}
        F_1(\opt) \defined 1 - e^{\opt},
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:F2}
        F_2(\opt) \defined 2\left[\opt - F_1(\opt)\right] - \segopt F_1(\opt),
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:G1}
        G_1(\segopt) \defined 1 + \frac{\segopt}{2} - \left(1 + \frac{1}{\segopt}\right)F_1(\segopt),
      \end{equation}
      \begin{equation}\label{eq:LSMOC:ET:G2}
        G_2(\segopt) \defined \frac{2}{3}\segopt - \left(1 + \frac{2}{\segopt}\right)G_1(\segopt),
      \end{equation}
      and
      \begin{equation}\label{eq:LSMOC:ET:H}
        H(\segopt) \defined \frac{\segopt}{2} - G_1(\segopt),
      \end{equation}
    \end{subequations}
    where $\opt$ is the variable optical thickness, and $\segopt$ is the total optical thickness of a segment.
    Although the functions $F_1(\opt)$, and $F_2(\opt)$ are functions of variable $\opt$, in the implementation of this method in code they are only ever evaluated over the full optical thickness, $\segopt$.
    The functions, $G_1(\segopt)$, $G_2(\segopt)$, and $H(\segopt)$ all require special treatment around $\segopt = 0$, in this work this is handled via Taylor interpolation about $\segopt=0$.

    [FIGURE][ADD PLOT OF THE FUNCTIONS]

    These functions all involve an exponential, $e^{-\segopt}$; although this does not present a problem mathematically, the exponential function is a transcendental function that tends to be slow when evaluated computationally.
    For efficient transport codes, this presents a challenge.
    Previous works have demonstrated that function interpolation can provide significant run-time reduction \cite{Yamamoto2004}, and the original formulation \cite{Ferrer2016} suggested the use of function interpolation (though no details were provided).

    \subsection{First Approach: Improved Accuracy}{\label{ssec:LSMOC:ET:First Approach: Improved Accuracy}
      With the implementation of \ac{LSA} into MPACT, stability issues were observed in problems with very small transport cross sections, such as the fuel-clad gap in \acp{LWR}.
      These stability issues were only observed when exponential function interpolation was used, and the simplest method for addressing the issue was to increase the accuracy of the exponential interpolation.
      It was discovered that the root of the problem was the $F_2(\segopt)$ function in the transmission equation
      \begin{equation}\label{eq:LSMOC:ET:Transmission Original}
        \afluxout = \afluxin
                  + \left(\frac{\tsrcF}{\xst}-\afluxin\right)F_1(\segopt)
                  + \frac{\tsrcL}{2\left(\xst\right)^2}F_2(\segopt).
      \end{equation}
      In MPACT, source terms are actually computed and stored as $q/\xst$; however the $F_2(\segopt)$ term has an additional inverse $\xst$.
      In problems with near-void regions, where $\xst$ is small, any error in $F_2(\segopt)$ interpolation will be magnified.
      The simplest approach is to increase the accuracy of the exponential interpolation to account for the lowest expected cross sections; in the test problem this was on the order of $10^{-5}$.
      Thus, the expectation is that an interpolation 5 orders of magnitude more accurate than previous accuracy would be sufficient.
      Previous work \cite{Yamamoto2004} indicated that for \ac{FSMOC} calculations an max interpolation error of $10^{-7}$ was sufficient, i.e. for \ac{LSMOC} the max error would be within $10^{-12}$.

      Creating interpolation tables with the necessary accuracy for these problems requires some care.
      The original investigation of exponential interpolation for transport calculations  done by \citet{Yamamoto2004} indicated two methods of controlling interpolation accuracy.
      One method to increase interpolation accuracy is to increase the number of intervals (decreased interval width); however, this increased the memory.
      Alternatively, higher order polynomials can be used in the interpolation, which overall tends to reduce memory at the expense of increased run-times.

      In this investigation, two additional methods for controlling accuracy were investigated: interpolation node choice, and non-uniform interval widths.
      \subsubsection{Interpolation Points}{\label{sssec:ET:Interpolation Points}
        Within each interval of an interpolation table, the function is computed at interpolation points and an approximation of the function is made as the polynomial passing through these points.
        The placement of these points within each interval can greatly affect the accuracy of the approximation.
        Previous works \cite{Yamamoto2004,Kochunas2013} used evenly spaced interpolation points within each interval; however, this does not minimize the error in the approximation.
        An example is shown in \cref{fig:LSMOC:ET:Interpolation Example}.

        \begin{figure}
          \centering
          \includegraphics[width=0.90\linewidth]{exponentials/interpolation-example}
          \caption{Example of linear interpolation with uniform interval widths and interpolation points on the edge of the domain.\label{fig:LSMOC:ET:Interpolation Example}}
        \end{figure}

        Let $P_n(x)$ be the order $n$ polynomial approximating a function, $f(x)$, on an arbitrary interval $[a,b]$.
        The maximum error, $\epsilon$, within an interval is given by
        \begin{equation}\label{eq:LSMOC:ET:Interpolation Error}
          \epsilon = \frac{1}{(n+1)!}\left(\max_{\xi\in[a,b]}\lrabs{f^{(n+1)}(\xi)}\right)\left(\max_{x\in[a,b]}\lrabs{\prodl[j=1][n+1](x-x_j)}\right),
        \end{equation}
        for some value $\xi\in[a,b]$, where $f^{(n+1)}$ is the $n+1$-th derivative of $f(x)$.
        The choice of interpolation points will only affect the last term enclosed in parentheses.

        The Chebyshev points \cite{Stewart1996} are a set of values in $[a,b]$ that minimize $\max_{x\in[a,b]}\lrabs{\prodl[j=1][n+1](x-x_j)}$, and are given by
        \begin{equation}\label{eq:LSMOC:ET:Chebyshev Points}
          x_k = \frac{1}{2}\left[(a+b)+(b-1)\cos\left(\frac{2k-1}{2(n+1)}\pi\right)\right], \forall k\in\{1,2,...,n,n+1\}.
        \end{equation}
        By using the Chebyshev points, the maximum interpolation error, $\epsilon$, can be simplified to
        \begin{equation}\label{eq:LSMOC:ET:Chebyshev Interpolation Error}
          \epsilon = \frac{1}{2^n(n+1)!}\left(\frac{b-a}{2}\right)^{n+1}\max_{\xi\in[a,b]}\lrabs{f^{(n+1)}(\xi)}.
        \end{equation}
        Because the Chebyshev points do not include the end-points of the interval, there is additional cost in setting up the interpolation table, but this is negligible to typical \ac{MOC} calculation times.
        An interpolation table using Chebyshev points \emph{reduces error at no run-time cost} compared to a table using evenly spaced points.
        For this reason, Chebyshev points will be assumed for the remainder of this section.
        \Cref{tab:LSMOC:ET:Chebyshev Error} shows maximum errors for $F_1(\opt)$ interpolation for uniformly spaced points and Chebyshev points for an interval width $\Delta=b-a$.
        \begin{table}
          \centering
          \renewcommand{\arraystretch}{1.45}
          \caption{Maximum error in $F_1(\opt)$ for interval width $\Delta$.}
          \label{tab:LSMOC:ET:Chebyshev Error}
          \begin{tabular}{@{}ccc@{}}\toprule
            Polynomial Order & Uniform points   & Chebyshev points\\\midrule
            1                & $\frac{\Delta^2}{8}$           & $\frac{\Delta^2}{16}$\\
            2                & $\frac{\Delta^3}{72\sqrt{3}}$  & $\frac{\Delta^3}{192}$\\
            3                & $\frac{\Delta^4}{1536}$        & $\frac{\Delta^4}{3072}$\\\bottomrule
          \end{tabular}
        \end{table}
      }
      \subsubsection{Interval Width}{\label{sssec:LSMOC:ET:Interval Width}
        The conventional approach for interpolation tables has been to use a constant interval width, $\Delta$, for all intervals in the domain.
        This interval width is then used to control the error of the table.
        \Cref{eq:LSMOC:ET:Interpolation Error} shows that the interval bounds affect the interpolation error through the derivative term.
        The second and higher order derivatives of each of the exponential functions (\cref{eqs:LSMOC:ET:Exponential Functions}) approach zero as $\segopt$ approaches infinity.
        This indicates that the interpolation error typically decreases as the optical thickness increases in the conventional approach.

        However, is is possible to maintain the same maximum error over each interval if a variable interval width, $\Delta_i$, is used, where $i$ indicates the interval index.
        By using a variable interval width, a table can use fewer intervals while maintaining the same maximum error.
        However, since the widths are no longer constant, there is no longer a simple/direct conversion from $\segopt$ to $i$.
        Although there may be better ways, for this work the smallest interval is used to break up the domain into a map which points to the correct interval for that range of values.

        It was found that the use of non-uniform interval widths allowed for significantly fewer total intervals, reducing the memory usage, but incurring overhead for the additional mapping to index.
        \Cref{fig:LSMOC:ET:Memory Analysis} shows the memory usage for a polar-independent interpolation table for $F_1(\segopt)$.
        Using a non-uniform table typically decreases the memory usage by nearly an order of magnitude.
        For polar-dependent tables, the memory usage will be multiplied by the largest inverse sine of the polar angle, and the number of polar angles.

        \begin{figure}
          \centering
          \includegraphics[width=0.90\linewidth]{exponentials/MemoryAnalysis}
          \caption{The memory usage of a single interpolation table (polar independent) for $F_1(\segopt)$ is shown as a function of the maximum error for different interpolation orders and tabulation methods.\label{fig:LSMOC:ET:Memory Analysis}}
        \end{figure}

        Because all the functions of \cref{eqs:LSMOC:ET:Exponential Functions} are related, it is possible to tabulate only a single function and compute the others from the resulting interpolated value.
        However, if $F_1(\segopt)$ is known accurately, it is not possible to compute $H(\segopt)$ for very small $\segopt$ due to round-off errors.
        Instead one can tabulate $H(\segopt)$ and use the result to compute the other functions; however, this may incur more error than directly interpolating these functions.
      }
    }
    \subsection{Function Modification}{\label{ssec:LSMOC:ET:Function Modification}
      A second approach for addressing the instability due to inaccurate function interpolation was taken: change the functions.
      Recall that the highly accurate interpolation tables of \cref{ssec:LSMOC:ET:First Approach: Improved Accuracy} were necessary due to the inverse total (or transport) cross section on the $F_2(\segopt)$ term of \cref{eq:LSMOC:ET:Transmission Original}.
      Manipulating this term, we define a new function
      \begin{equation}\label{eq:LSMOC:ET:F2 Modified Definition}
        \frac{F_2(\segopt)}{\xst} = \nlen\modFunc,
      \end{equation}
      where
      \begin{equation}\label{eq:LSMOC:ET:F2 Modified}
        \modFunc \defined 2\left(1-\frac{F_1(\segopt)}{\segopt}\right) - F_1(\segopt).
      \end{equation}
      The $\modFunc$ function can be tabulated in place of $F_2(\segopt)$; this will require an additional multiplication by the segment length $\nsegl$ causing slight reduction in performance.
      But, by using the modified $\modFunc$ function, the underlying cause of the numerical instability is addressed, and the more accurate interpolation is no longer necessary.

      One approach is to tabulate the $\modFunc$ function in place of the $F_2(\segopt)$ function, and multiply by $\nsegl$ during evaluation.
      However, as stated in the previous section, it is possible to tabulate a single function and compute the others.
      The $H(\segopt)$ function could be tabulated again; but tabulating an intermediate function,
      \begin{equation}\label{eq:LSMOC:ET:E1}
        E_1(\segopt) \defined \frac{1-e^{-\segopt}}{\segopt},
      \end{equation}
      uses the same number of operations to compute the other functions.
      This $E_1(\segopt)$ function also has smaller derivative terms around $\segopt=0$, allowing for larger interval widths with no loss in accuracy.
      Therefore, it is expected that $E_1(\segopt)$ tabulation will be more efficient.
    }
    \subsection{Results}{\label{ssec:LSMOC:ET:Results}
      The results of this section were generated in serial on a Linux system with an Intel Xeon E3-1241 v3 (3.50 GHz) processors with 8 MB L3 cache.
      Results were generated for a 2-D \ac{MOC} transport calculation.
      In 2-D it is sometimes convenient to store separate interpolation tables for each polar angle.
      Both polar dependent and independent tables were tested.

      In both of the results sections, results were generated using tables for the three functions ($F_1(\segopt)$, $F_2(\segopt)$, $H(\segopt)$), or a single function (which is then used to compute the others).
      In the results, it is considered 3 functions, as the $G_1(\segopt)$, and $G_2(\segopt)$ functions are only used in pre-computing coefficients, and not in the main \ac{MOC} solver routine.

      \subsubsection{Results using More Accurate Tables}{\label{sssec:LSMOC:ET:Results using More Accurate Tables}
        \Cref{tab:LSMOC:ET:Naive Results} shows results for the different interpolation methods in a 2-D \ac{MOC} calculation.
        The use of non-uniform intervals significantly reduced the memory usage, but the run-times generally increased.
        This is likely due to the overhead from the additional index mapping operation; it is possible that a more efficient index mapping would change these results.

        The linear tables were significantly slower than higher-order interpolations, and the non-uniform linear tables were actually slower than just using the builtin transcendental functions.
        The poor performance is due to the main memory accesses caused by the table size exceeding the largest (L3) cache size.
        The polar independent tables were faster only in the case of the linear tables, due primarily to the reduction in memory.
        In all other cases the polar-dependent tables were able to more efficiently approximate the functions.
        Using either second or third order tables gave reasonably low run-times; compared to the analytic evaluations the order 2 uniform polar dependent table led to $\sim 3.5$x speed-up in the exponential time, and $\sim 1.9$x speed-up in the overall \ac{MOC} run-time.
        The results for both second and third order interpolation tables did not vary significantly, the second order was slightly faster for uniform tables.

        However, if a single function is tabulated and used to compute the others, the memory footprint of the interpolation tables can be significantly reduced.
        Moreover, the memory accesses are reduced in favor of floating point operations which increases the computational intensity and temporal cache locality of the implementation.
        Generally, this is a favorable strategy for improving code performance as a memory access is expected to take \emph{at minimum} the same time as a single \ac{FLOP}, with cache-misses increasing that time.
        Indeed, \cref{tab:LSMOC:ET:Naive Results} shows that tabulating the single function reduced run-time in all cases.

        \begin{table}
          \centering
          \caption{Results for different exponential function evaluation methods. Maximum interpolation error of $10^{-12}$. ``w/ pol'' indicates a table with polar dependence, and ``w/o pol'' indicates a table without polar dependence.}
          \label{tab:LSMOC:ET:Naive Results}
          \footnotesize
          \begin{tabular}{@{}ccrrrrrrrrr@{}}\toprule
            Method & Table Type & Order & \multicolumn{2}{c}{\shortstack[c]{Exponential\\Time (s)}} & & \multicolumn{2}{c}{\ac{MOC} Time (s)} && \multicolumn{2}{c}{Intervals (Memory)}\\\cmidrule{4-5}\cmidrule{7-8}\cmidrule{10-11}
                  &            &       & w/ pol & w/o pol & \phantom{}                           & w/ pol & w/o pol & \phantom{}  &  \multicolumn{1}{c}{w/ pol} & \multicolumn{1}{c}{w/o pol}\\\midrule
            Analytic & N/A & N/A & \multicolumn{2}{c}{432.5} && \multicolumn{2}{c}{654.7} && \multicolumn{2}{c}{N/A}\\\midrule
            \multirow{6}{*}{3-Functions}     & \multirow{3}{*}{Uniform}        & 1 & 382.6 & 360.3 && 622.5 & 591.0 && 6.00E7 (8.04 GB) & 1.00E7 (458 MB) \\\addlinespace[-0.2em]
                                                                              && 2 & 121.3 & 151.7 && 343.2 & 372.1 && 416080 (85.7 MB) & 69360  (4.8 MB) \\\addlinespace[-0.2em]
                                                                              && 3 & 124.1 & 169.0 && 347.5 & 388.7 && 32280  (9079 KB) & 5400   (506 KB) \\\cmidrule{2-11}\addlinespace[-0.2em]
                                                & \multirow{3}{*}{Non-Uniform} & 1 & 592.9 & 559.2 && 825.8 & 800.6 && 4.07E6  (878 MB) & 840658 (76.6 MB)\\\addlinespace[-0.2em]
                                                                              && 2 & 144.6 & 178.5 && 364.3 & 397.8 && 45265  (10.9 MB) & 8020    (835 KB)\\\addlinespace[-0.2em]
                                                                              && 3 & 139.6 & 199.8 && 358.5 & 420.0 && 4491    (1.4 MB) & 796    (85.2 KB)\\\midrule
            \multirow{6}{*}{1-Function}       & \multirow{3}{*}{Uniform}       & 1 & 296.2 & 259.3 && 523.9 & 484.5 && 6.00E7 (2.68 GB) & 1.00E7  (153 MB)\\\addlinespace[-0.2em]
                                                                              && 2 &  91.4 & 123.2 && 310.2 & 345.7 && 416080 (28.6 MB) & 69360  (1.59 MB)\\\addlinespace[-0.2em]
                                                                              && 3 &  87.2 & 133.2 && 305.4 & 353.6 && 32280  (2.96 MB) & 5400    (169 KB)\\\cmidrule{2-11}\addlinespace[-0.2em]
                                                & \multirow{3}{*}{Non-Uniform} & 1 & 474.6 & 424.0 && 714.6 & 653.9 && 4.07E6  (415 MB) & 722899 (49.2 MB)\\\addlinespace[-0.2em]
                                                                              && 2 & 105.8 & 146.4 && 326.6 & 367.7 && 41444   (4.4 MB) & 7338   (443  KB)\\\addlinespace[-0.2em]
                                                                              && 3 &  98.9 & 153.3 && 318.8 & 373.2 && 4152    (515 KB) & 735    (33.5 KB)\\\bottomrule
          \end{tabular}
        \end{table}
      }
      \subsubsection{Results using Modified Function}{\label{sssec:LSMOC:ET:Results using Modified Function}
        Results were generated for the same cases as the more accurate table, but the interpolation accuracy was $10^{-7}$ rather than $10^{-12}$, as the function modification addressed the cause of the instability.
        The results are summarized in \cref{tab:LSMOC:ET:Final Results}.
        In one approach the three functions are tabulated, in the other $E_1(\segopt)$ is tabulated and used to compute the three functions.
        Previous results showed that the polar-independent and non-uniform interval width tables were slower than uniform polar-dependent tables; here the results are only shown for the uniform polar-dependent interpolation tables.

        The interpolation accuracy is not required to be as high as in the previous cases, thus the tables are significantly smaller in memory size.
        The linear tables no longer exceed the L3 cache size and are not prohibitively slow to use.
        In fact, the linear tables are the fastest option for both 3-table and single-table interpolation methods.
        Interpolating $E_1(\segopt)$ and computing the other functions from the result was the fastest approach overall.
        As before, this is expected because this method favors \acp{FLOP} over memory accesses.

        This approach also significantly reduces the number of intervals necessary (by about 3 orders of magnitude).
        Although the higher-order interpolation ended up not being more efficient than the linear interpolation tables, the number of intervals is extremely small.
        These methods may be useful on different architectures (such as \acp{GPGPU}\footnote{this statement was not confirmed as part of this study, and is speculation based on knowledge of architecture constraints.}) where memory is more limited than on a single-threaded \ac{CPU} calculation.

        \begin{table}
          \centering
          \caption{Results using the modified $\modFunc$ function, with maximum interpolation error of $10^{-7}$. Memory is under 1 MB in all cases.}
          \label{tab:LSMOC:ET:Final Results}
          \begin{tabular}{@{}ccccc@{}}\toprule
            Method & Order & Exp.     & \ac{MOC}& \# Intervals \\
                   &       & Time (s) & Time (s) & \\\midrule
            \multirow{3}{*}{3-Functions}      & 1 &  88.4 & 307.9 & 4774\\
                                              & 2 &  99.7 & 316.8 &  225\\
                                              & 3 & 116.5 & 333.1 &   46\\\midrule
            \multirow{3}{*}{$E_1(\opt)$ Only} & 1 &  80.5 & 299.0 & 2739\\
                                              & 2 &  87.6 & 307.3 &  158\\
                                              & 3 &  99.0 & 317.7 &   38\\\bottomrule
          \end{tabular}
        \end{table}
      }
    }
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Conclusions
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Conclusions}{\label{ssec:LSMOC:ET:Conclusions}
      This study focused on the investigation of efficient approximation of the exponential functions in the \ac{LSMOC}.
      Methods for efficiently approximating the exponential function for \ac{FSMOC} have previously been investigated.
      However, these methods, applied without modification to the \ac{LSMOC} can lead to numerical instability in problems with near-void regions.
      One approach to deal with these instabilities is to improve the accuracy of the interpolation tables based on the lowest cross section in the problem.
      While this approach can be made efficient, if cross sections become too small the tables may become exceedingly large and significantly hamper performance.

      This investigation revealed that the cause of the instability was the $F_2(\segopt)$ function in the transmission equation.
      By instead manipulating the term including this function, the cause of the instabilities can be addressed.
      This approach no longer requires excessively large interpolation tables; however, some key-findings from the first approach can be applied to make this appraoch faster.
      First, the use of Chebyshev points significantly increases interpolation accuracy for the same number of intervals as uniformly spaced points, at no run-time cost.
      Additionally, by interpolating a single function and using the result to compute the other functions performance can be significantly improved.
    }
  }
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Improved Linear Source Formulation for Multi-physics and 2D/1D Applications
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}{\label{sec:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}
    \blindtext
    \subsection{Derivation}{\label{ssec:LSMOC:Derivation}
      \blindtext[5]
    }
    \subsection{Results}{\label{ssec:LSMOC:Results}
      \blindtext[5]
    }
  }


  % References
  \printbibliography
}


% \subsection{Derivation}{\label{ssec:MOC:LSA:Derivation}
% The moment-based \ac{LSA} assumes the shape of the source, $\source[mi][g][\loc]$, is spatially linear within each cell, $\Region$.
% This can be expressed as
% \begin{subequations}\label{eqs:MOC:LSA:Source Shape}
%     \begin{equation}\label{eq:MOC:LSA:Source Shape}
%         \source[mi][g][\loc] \approx \srcF[mi] + \loc\vdot\srcL,
%     \end{equation}
%     where $\srcL$ is a column vector of source spatial expansion coefficients,
%     \begin{equation}
%         \srcL \defined\begin{bmatrix}\srcL[x]\\\srcL[y]\\\srcL[z]\end{bmatrix},
%     \end{equation}
%     and $\loc$ is the position in \emph{local} coordinates.
% \end{subequations}
% A similar spatial expansion of the angular moments of the flux can be performed,
% \begin{equation}\label{eq:MOC:LSA:Flux Expansion}
%     \fluxA(\loc) = \fluxF + \loc\vdot\fluxL,
% \end{equation}
% the source can then be expressed as
% \begin{equation}\label{eq:MOC:LSA:Linear Source Computation}
%     \source[mi][g][\loc]
%         = \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]\fluxA[\gprime](\loc)
%         + \frac{\spect}{\keff}\suml[\gprime]\nufis\sflux[\gprime](\loc),
% \end{equation}
% and the linear expansion coefficients are explicitly given by
% \begin{equation}\label{eq:MOC:LSA:Linear Source Coefficients}
%     \srcL
%         = \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]\fluxL[\gprime]
%         + \frac{\spect}{\keff}\suml[\gprime]\nufis\sfluxL[\gprime].
% \end{equation}

% In the spatial moment-base \ac{LSA}, it is convenient to define the spatially linear source (and flux) in terms of a cell-local coordinate system.
% Allow $\Loc$ to be the position variable in the global coordinate system, the local coordinates are then defined as
% \begin{equation}\label{eq:MOC:LSA:Global to Local Coordinates}
%     \loc = \Loc - \centroid[\Loc][mi],
% \end{equation}
% where $\centroid[\Loc][mi]$ is the numerical centroid of the cell $i$.

% These numerical centroids can be defined as either direction-dependent, or direction-independent, which will have implications on particle conservation, as discussed in \cref{ssec:MOC:LSA:Particle Conservation}.
% The direction-dependent centroids are defined by
% \begin{equation}\label{eq:MOC:LSA:Direction-Dependent Centroids}
%     \centroid[\Loc][mi] \defined \MOCSingleAngleIntegral{\Loc} = \frac{1}{V_i}\suml[k]\tA[mki]\nsegl\locCent[\Loc],
% \end{equation}
% where $\locCent[\Loc]$ is the global coordinate vector of the track-segment mid-point.
% Similarly, the direction-independent centroids are defined by
% \begin{equation}\label{eq:MOC:LSA:Direction-Independent Centroids}
%     \centroid[\Loc][i] \defined \rfourpi\MOCIntegral{\Loc} = \frac{1}{V_i}\suml[m]\wt\suml[k]\tA[mki]\nsegl\locCent[\Loc].
% \end{equation}

% Following the same approach as the \ac{FSMOC} derivation, in \cref{ssec:MOC:FSA:Derivation}, computing the source the region-averaged flux moment, $\fluxF$, and the flux expansion coefficients, $\fluxL$, are required.
% \begin{subequations}\label{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions}
%     The region-averaged flux moment can be found using the same definition as previously,
%     \begin{equation}\label{eq:MOC:LSA:Region-Averaged Flux Moment Definition}
%         \fluxF \defined \MOCIntegral{\SH \aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\MOCTrackIntegral{\aflux[][g][]}.
%     \end{equation}
%     In order to determine the spatial expansion coefficients of the flux moments, \cref{eq:MOC:LSA:Flux Expansion} is operated on by $\MOCIntegral{\SH(\vdot)\loc^T}$.
%     Recognizing that this should be directly proportional to angular flux operated on by $\MOCIntegral{\SH\aflux[][g][]\loc^T}$, a system of equations is found
%     \begin{equation}\label{eq:MOC:LSA:Moment to Expansion Coefficient}
%         \M\fluxL = \MOCIntegral{\SH\loc\aflux[][g][]},
%     \end{equation}
%     where
%     \begin{equation}\label{eq:MOC:LSA:Geometric Moments}
%         \M \defined \MOCIntegral{\loc^T\loc}.
%     \end{equation}
%     The spatial angular flux moments, $\MOCIntegral{\SH\loc\aflux[][g][]}$, are then defined as
%     \begin{equation}\label{eq:MOC:LSA:Revion-Averaged Spatial Angular Flux Moments Definition}
%         \MOCIntegral{\SH\loc\aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\left(\locIn\MOCTrackIntegral{\aflux[][g][]} + \dirm\MOCTrackIntegral{\nlen\aflux[][g][]} / \renorm[mi]\right).
%     \end{equation}
% \end{subequations}

% In order to evaluate the flux moments defined in \cref{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions}, the track-averaged angular flux values, $\MOCTrackIntegral{\aflux[][g][]}$, and $\MOCTrackIntegral{\nlen\aflux[][g][]}$, must be determined.
% First, the transport equation must be put into characteristic form, using \cref{eq:MOC:Renormalized Location Variable} the spatially expanded source, \cref{eq:MOC:LSA:Source Shape}, can be defined along the characteristic.
% \begin{subequations}\label{eqs:MOC:LSA:Characteristic Form}
%     The characteristic transport equation becomes
%     \begin{equation}\label{eq:MOC:LSA:Characteristic Form}
%         \left[\deriv{}{\nlen} + \xst\right]\aflux = \tsrcF + \tsrcL\left(\nlen - \frac{\nsegl}{2}\right),
%     \end{equation}
%     where
%     \begin{equation}\label{eq:MOC:LSA:Track Average Source}
%         \tsrcF \defined \rfourpi\left[\srcF[mi] + \locCent \vdot \srcL\right],
%     \end{equation}
%     and
%     \begin{equation}\label{eq:MOC:LSA:Track Linear Source}
%         \tsrcL \defined \rfourpi\left[\frac{\dirm\vdot\srcL}{\renorm[mi]}\right].
%     \end{equation}
% \end{subequations}
% This can be solved analytically for the angular flux along the track,
% \begin{subequations}\label{eqs:MOC:LSA:Angular Flux Solution}
%     \begin{equation}\label{eq:MOC:LSA:Angular Flux Solution}
%         \aflux = \afluxin + \left(\frac{\tsrcF}{\xst} - \afluxin\right)F_1(\opt) + \frac{\tsrcL}{2(\xst)^2}F_2(\opt),
%     \end{equation}
%     where
%     \begin{equation}\label{eq:MOC:LSA:F1}
%         F_1(\opt) \defined 1 - \exp(-\opt),
%     \end{equation}
%     and
%     \begin{equation}\label{eq:MOC:LSA:F2}
%         F_2(\opt) \defined 2[\opt-F_1(\opt)] - \segopt F_1(\opt).
%     \end{equation}
% \end{subequations}

% As discussed in \cref{ssec:MOC:FSA:Derivation}, there are two \emph{equivalent} methods with which one could determine the track-averaged angular flux values.
% However, it is the author's opinion that defining these moments implicitly, by taking the moments of the characteristic equation (\cref{eq:MOC:LSA:Characteristic Form}), results in a form that is simpler.
% The original basis of this work \cite{Ferrer2016}, evaluated the linear moment explicitly; for brevity, the derivation will only be shown here with the implicitly defined moment.
% Previous work \cite{Fitzgerald2019} has also shown that by using the form given by the implicit definition, there are significant benefits in multi-physics applications.
% The implicitly defined moments, given by operating on \cref{eq:MOC:LSA:Characteristic Form} by $\MOCTrackIntegral{(\vdot)}$ and $\MOCTrackIntegral{\nlen(\vdot)}$, are given by
% \begin{subequations}\label{eqs:MOC:LSA:Track-Averaged Moments}
%     \begin{equation}\label{eq:MOC:LSA:Track-Averaged Angular Flux}
%         \MOCTrackIntegral{\aflux[][g][]} = \frac{\tsrcF}{\xst} + \frac{\dflux}{\segopt},
%     \end{equation}
%     and
%     \begin{equation}\label{eq:MOC:LSA:Track-Averaged Linear Angular Flux}
%         \MOCTrackIntegral{\nlen\aflux[][g][]} = \frac{\MOCTrackIntegral{\aflux[][g][]} - \afluxout}{\xst} + \frac{\nsegl}{2}\left[\frac{\tsrcF}{\xst} + \frac{\tsrcL}{\xst}\frac{\nsegl}{6}\right].
%     \end{equation}
% \end{subequations}
% Due to the presence of the $\dflux/\segopt$ term in \cref{eq:MOC:LSA:Track-Averaged Linear Angular Flux}, it is beneficial to stability and performance \cite{Fitzgerald2018,Fitzgerald2019} to compute this quantity directly, rather than computing $\dflux$ (as is done for \ac{FSMOC}).
% \begin{subequations}\label{eqs:MOC:LSA:Delta Flux over Optical Thickness}
%     This can be found explicitly by subtracting \cref{eq:MOC:LSA:Angular Flux Solution} evaluated at the exiting location from $\afluxin$ and dividing by $\segopt$, to get
%     \begin{equation}\label{eq:MOC:LSA:Delta Flux over Optical Thickness}
%         \frac{\dflux}{\segopt} = \left(\afluxin-\frac{\tsrcF}{\xst}\right)E_1(\segopt) - \frac{\nsegl}{2}\frac{\tsrcL}{\xst}T_2(\segopt),
%     \end{equation}
%     where
%     \begin{equation}\label{eq:MOC:LSA:E1}
%         E_1(\segopt) \defined \frac{F_1(\segopt)}{\segopt},
%     \end{equation}
%     \begin{equation}\label{eq:MOC:LSA:T2}
%         T_2(\segopt) \defined 2E_2(\segopt) - E_1(\segopt),
%     \end{equation}
%     and
%     \begin{equation}\label{eq:MOC:LSA:E2}
%         E_2(\segopt) \defined \frac{1-E_1(\segopt)}{\segopt}.
%     \end{equation}
% \end{subequations}
% }
% \subsection{Particle Conservation}{\label{ssec:MOC:LSA:Particle Conservation}
% In consideration to particle balance, use of the \ac{LSA} results in additional constraints on the calculations.
% Similarly to \cref{ssec:MOC:FSA:Particle Conservation}, the track-based integration of the source must exactly integrate to the spatial and angular moments of the source.
% The conservation of spatial moments is the basis of this \ac{LSA} \cite{Ferrer2018}, so this constraint is satisfied without additional constraints on the method.
% The angular moment constraint is expressed as
% \begin{equation}\label{eq:MOC:LSA:Angular Moment Constaint}
%     \rfourpi\MOCIntegral{\SH\source[mi][g][\loc]} = \srcF[i,\ell][g,n].
% \end{equation}
% In addition to the constraints introduced in \cref{ssec:MOC:FSA:Particle Conservation}, namely direction-dependent renormalization, and directional quadrature restrictions, this places constraints on the definition of the local coordinate system:
% \begin{equation}\label{eq:MOC:LSA:Anisotropic Coordinate Constraint}
%     \MOCSingleAngleIntegral{\loc} = 0.
% \end{equation}
% This is equivalent to stating that the local coordinate system must be defined with respect to direction-dependent global centroids, as is given by \cref{eq:MOC:LSA:Direction-Dependent Centroids}.

% If these constraints are satisfied, \cref{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions} can be simplified,
% \begin{subequations}\label{eqs:MOC:LSA:Region-Averaged Flux Moments}
%     \begin{equation}\label{eq:MOC:LSA:Region-Averaged Scalar Flux}
%         \sflux = \frac{\srcF}{\xst} + \frac{\fourpi}{V_i\xst}\suml[m]\wt[m]\suml[k]\tA[mki]\dflux,
%     \end{equation}
%     \begin{equation}\label{eq:MOC:LSA:Region-Averaged Angular Moments of Flux}
%         \fluxF = \frac{\tsrcF[i,\ell][g,n]}{\xst} + \frac{\fourpi}{V_i\xst}\suml[m]\wt[m]\SH[\ell][n][\dirm]\suml[k]\tA[mki]\dflux,
%     \end{equation}
%     and
%     \begin{aequation}\label{eq:MOC:LSA:Region-Averaged Spatial Moments of Flux}
%         \MOCIntegral{\loc\SH\aflux[][g][]}
%             &= \suml[m]\wt\SH[\ell][n][\dirm]\M[][mi]\frac{\srcL[][mi]}{\xst}\\
%             &+ \frac{\fourpi}{V_i\xst}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]
%                 \tA\left[\locIn\dflux + \dirm\segl\left(\frac{\dflux}{\segopt}-\afluxout + \frac{\tsrcF}{\xst}\right)\right]
%     \end{aequation}
%     where
%     \begin{equation}\label{eq:MOC:LSA:Delta Flux}
%         \dflux \defined \afluxin - \afluxout,
%     \end{equation}
%     and
%     \begin{equation}\label{eq:MOC:LSA:Direction Dependent M}
%       \M[][mi] \defined \MOCSingleAngleIntegral{\loc^T\loc}.
%     \end{equation}
% \end{subequations}
% }
% \subsection{Spatial and Isotropic Simplifications}{\label{ssec:MOC:LSA:Isotropic Simplifications}
% The work introducing the original formulation of the moment-based \ac{LSA} suggests that it is beneficial to allow only the isotropic moments of the source and flux to be spatially linear, while higher order moments are spatially flat.
% The reformulation introduced as part of this work \cite{Fitzgerald2019} was extended to make this simplification in the so called \acf{LIFA} source [CITATION].
% The linear moment equations can then be simplified to
% \begin{aequation}\label{eq:MOC:LSA:LIFA Region-Averaged Spatial Moments of Flux}
%     \MOCIntegral{\loc\aflux[][g][]}
%         &= \M\frac{\srcL}{\xst}
%         + \frac{\fourpi}{V_i\xst}\suml[m]\wt\suml[k]
%             \tA\left[\locIn\dflux + \dirm\segl\left(\frac{\dflux}{\segopt} - \afluxout + \frac{\tsrcF}{\xst}\right)\right].
% \end{aequation}

% In the case of an isotropic source, the constraints for particle balance are relaxed.
% Track-length renormalization as well as numerical centroid definitions can be direction-independent while still preserving particle conservation \cite{Ferrer2018}, as given by \cref{eq:MOC:Region Renormalization}, and \cref{eq:MOC:LSA:Direction-Independent Centroids} respectively.
% The calculation of angular flux spatial moments, given in \cref{eq:MOC:LSA:Region-Averaged Spatial Moments of Flux}, can also be simplified into the form
% \begin{equation}\label{eq:MOC:LSA:Region-Averaged Spatial Moments of Flux Isotropic}
%     \MOCIntegral{\loc\aflux[][g][]}
%             = \M\frac{\srcL}{\xst}
%             + \frac{\fourpi}{V_i\xst}\suml[m]\wt\suml[k]\tA
%                 \left(\dirm\segl\left[\frac{\dflux}{\segopt} - \afluxout\right]+ \locIn\dflux\right).
% \end{equation}
% }