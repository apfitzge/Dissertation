\chapter{The Method of Characteristics}{\label{ch:The Method of Characteristics}
    \input{macros/multigroup.tex}
    \input{macros/DiscreteOrdinates.tex}
    \input{macros/MOC.tex}
    \def\figpath{chapters/MOC/figures/}
    \graphicspath{ {\figpath} }

    \section{Fundamentals}{\label{sec:MOC:Fundamentals}
        The \acf{MOC} is a technique used to solve first-order \acp{PDE}, by transforming the \ac{PDE} into a system of \acp{ODE}.
        The method was first applied to the neutron transport equation by \citeauthor{Askew1972} in 1972 \cite{Askew1972}, but only began to see real use in the 1980's \cite{Halsall1980}.
        The \ac{MOC} transforms the transport equation into the characteristic form, by following the equation along straight neutron paths through the spatial domain.
        For brevity, the derivation of this method will begin with the multigroup \ac{SN} $k$-eigenvalue transport equation with spatially discretized mesh with constant material properties within each cell.
        Here, the spatial derivatives have not yet been discretized.
        \begin{equation}\label{eq:MOC:SSMGFS Transport}
            \left[\dirm\vdot\grad + \xst\right]\aflux[mi][g][\loc] = \rfourpi\source[mi][g][\loc],
        \end{equation}
        \begin{equation*}
            \forall\loc\in\Region, \quad \forall m \in \angquad, \quad \forall i, g,
        \end{equation*}
        where $\Region$ is the spatial cell, $\angquad$ is the directional quadrature, as described in \cref{sssec:NTT:Directional Discretization}, and the fixed-source, $
        \source[mi][g][\loc]$ can be found by applying the discrete-to-moment operator, $\FluxToSource$, defined by
        \begin{equation}\label{eq:MOC:LSA:Flux To Source Operator}
          \FluxToSource(f) \defined
            \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]f^{\ell,\gprime}_{n,i}(\loc)
            + \frac{\spect}{\keff}\suml[\gprime]\nufis f^{\gprime}_{i}(\loc),
        \end{equation}
        to get
        \begin{equation}\label{eq:MOC:Source}
            \source[mi][g][\loc] \defined
                \left[\suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH\xss[\ell]\afluxmom(\loc) + \frac{\spect}{\keff}\suml[\gprime]\nufis\sflux[\gprime](\loc)\right],
        \end{equation}
        where $L$ is the maximum scattering order.
        If $L$ were infinite, there would not any additional approximation to the scattering source; however, the first several orders have the most effect on the figures of merit, and in practice the sum is truncated with $L$ typically being less than five.

        Consider a point, $\loc_0$, and a line passing through this point in direction $\dirm$.
        Any location along this \emph{characteristic} line (also referred to as a ray, or track), can be described as
        \begin{equation}\label{eq:MOC:Characteristic Ray}
            \loc = \loc_0 + \len\dirm,
        \end{equation}
        where $\len$ is the distance along the track from $\loc_0$.
        Applying this transformation, \cref{eq:MOC:SSMGFS Transport} is put into the characteristic form
        \begin{equation}\label{eq:MOC:Characteristic Form Deriv 1}
            \left[\deriv{}{\len} + \xst\right]\aflux[mi][g][\loc_0 + \len\dirm] = \rfourpi\source[mi][g][\loc_0 + \len\dirm].
        \end{equation}
        As stated in \cref{sec:NTT:Neutron Transport Equation}, reactor physicists are generally interested in spatially and directionally integrated angular flux quantities rather than the angular flux along a single path.
        Thus typical in the \ac{MOC} to have many different characteristic tracks through our problem; in this work separate tracks will be subscripted with the index $k$.
        Each track is broken up into track-segments by considering the segments contained within each computational cell.
        The characteristic form of the transport equation then becomes
        \begin{equation}\label{eq:MOC:MOC Equation Generic}
            \left[\deriv{}{\len} + \xst\right]\aflux = \rfourpi\source[mi][g][\len],
        \end{equation}
        \begin{equation*}
            \forall \len \in [0,\segl], \forall m\in\angquad, \forall i,k,g,
        \end{equation*}
        where $\segl$ is the total length of the track-segment, as depicted in \cref{fig:MOC:MOC Coordinate System}.

        \begin{figure}[h]
            \centering
            \def\svgwidth{0.4\linewidth}
            \input{\figpath/MOCCoordinateSystem.pdf_tex}
            \caption{Depiction of a single characteristic track through a cell $i$.}
            \label{fig:MOC:MOC Coordinate System}
        \end{figure}

        \Cref{eq:MOC:MOC Equation Generic} can be solved analytically along a characteristic track-segment using an integrating factor,
        \begin{equation}\label{eq:MOC:Integrating Factor}
            M(\len) = \exp\!\left(\intl[0][\len]\xst\dif{s'}\right) = \exp\!\left(\opt\right),
        \end{equation}
        where the \emph{optical thickness}, $\opt$, can be simplified as
        \begin{equation}\label{eq:MOC:Optical Thickness Definition}
            \opt \defined \xst\len,
        \end{equation}
        \begin{equation*}
          \forall \len \in [0,\segl],
        \end{equation*}
        assuming constant properties along the track-segment.
        Using this integrating factor, the generic solution to the \ac{MOC} equation, given in \cref{eq:MOC:MOC Equation Generic}, is
        \begin{equation}\label{eq:MOC:MOC Generic Solution}
            \aflux = \afluxin\exp\!\left(-\opt\right) + \intl[0][\len]\rfourpi\source[mi][g][\len']\exp\!\left(-\xst\left[\len-\len'\right]\right)\dif{s'},
        \end{equation}
        where $\afluxin$ is the incident angular flux, $\aflux[mki][g][0]$.
        If a source shape is provided, \cref{eq:MOC:MOC Generic Solution} can be evaluated for every track-segment in the problem.
        The next subsection introduces formal methods to approximate the integration of quantities over both space and direction.
        These procedures can be used to determine the scalar flux or other quantities necessary in \ac{MOC} calculations.

        \subsection{Track-Based Integration}{\label{ssec:MOC:Track-Based Integration}
            Determining the angular flux along a single characteristic track is typically not the goal of reactor physics calculations.
            It is most often necessary to evaluate reaction rates, and therefore the scalar flux through integration of the angular flux.
            This section aims to provide a formal basis for the integration process used in the \ac{MOC} for transport calculations.

            \begin{figure}[h]
                \centering
                \def\svgwidth{0.4\linewidth}
                \input{\figpath/MOCTracks.pdf_tex}
                \caption{Example characteristic tracks (2D) through a cell for a single direction.}
                \label{fig:MOC:MOC Tracks}
            \end{figure}

            The \ac{MOC} is based on the \acf{SN} approximation; integration over the directional variable simply becomes a quadrature integration:
            \begin{equation}\label{eq:MOC:Directional Quadrature Integration}
                \intl[\fourpi]f(\dir)\ddir \approx \fourpi\suml[m]\wt[m]f(\dirm).
            \end{equation}
            Within a cell, $\Region$, there are many characteristic track-segments for each direction in the directional quadrature, as is shown for a single direction in \cref{fig:MOC:MOC Tracks}.
            Thus, the spatial discretization is different for each direction, and spatial integration is linked with the directional integration.
            For a single direction, the integration over the spatial domain can be approximated by the weighted summation of track-averaged values, with the weight being equal to the area of the track-segment.
            The average value of a function, $f(\loc,\dirm)$, along a track-segment is denoted as
            \begin{equation}\label{eq:MOC:Track-Averaged Definition UnRenormalized}
                \MOCTrackIntegral{f(\loc,\dirm)} \defined \frac{1}{\segl}\intl[0][\segl]f(\len,\dirm)\dif{\len},
            \end{equation}
            where $\segl$ is the total length of the track-segment.
            The spatial integration for a single direction becomes
            \begin{equation}\label{eq:MOC:Spatial Averaging Definition UnRenormalized}
                \frac{1}{V_i}\intl[\loc\in\Region]f(\loc,\dirm)\dif^3{\loc} \approx \MOCSingleAngleIntegral{f(\loc,\dirm)} \defined \frac{1}{V_i}\suml[k]\tA[mki]\segl\MOCTrackIntegral{f(\loc,\dirm)} ,
            \end{equation}
            where $\tA[mki]$ is the cross-sectional area of the track (width in 2-D).
            In this notation, the integral is divided by the volume such that $\MOCSingleAngleIntegral{f}$ is approximately the mean value in the region, for the direction $\dirm$.
            Finally, an integration over both space and angle can be defined as
            \begin{equation}\label{eq:MOC:Spatial and Directional Integration Definition}
                \MOCIntegral{f(\loc,\dir)} = \fourpi\suml[m]\wt[m]\MOCSingleAngleIntegral{f(\loc,\dirm)}.
            \end{equation}

            These integrations have been expressed as 3-D \ac{MOC} equations.
            The general form remains the same for 2-D calculations, with minor changes.
            The spatial integration, \cref{eq:MOC:Spatial Averaging Definition UnRenormalized}, requires an additional scaling factor ($\sin(\Polar_p)$), and the volume, $V_i$, is the area of the cell:
            \begin{equation}
              \label{eq:MOC:Spatial Averaging Definition UnRenormalized 2D}
              \frac{1}{V_i}\intl[\loc\in\Region]f(\loc,\dirm)\dif^3{\loc} \approx \MOCSingleAngleIntegral{f(\loc,\dirm)} \defined \frac{\sin(\Polar_p)}{V_i}\suml[k]\tA[mki]\segl\MOCTrackIntegral{f(\loc,\dirm)}
            \end{equation}
            The scaling factor is necessary (but not sufficient) for the integrated cell area to be preserved for each polar angle;
            if $\sin(\Polar_p)$ is factored into the summation, $s_{mki}$ becomes $s_{aki}$ (the 2-D track-length).
        }
        \subsection{Track-Length Renormalization}{\label{sec:MOC:Track-Length Renormalization}
            In general, the spatial integration described in \cref{ssec:MOC:Track-Based Integration} does not preserve the cell volume; this is visually apparent in \cref{fig:MOC:MOC Tracks}.
            In order to preserve spatial volumes within a cell, track-lengths are often ``renormalized''.
            As the area of each ray, $\tA[mki]$ approaches zero, the renormalization becomes irrelevant; thus it is only of consequence when rays have relatively coarse spacing between each other.
            There are three renormalization methods that become obvious through the notation presented in \cref{ssec:MOC:Track-Based Integration}:
            \begin{enumerate}
                \item{segment-volume preservation}
                \item{direction-volume preservation}
                \item{volume preservation}
            \end{enumerate}

            Track-length renormalization involves adjusting the lengths of track-segments such that volume is preserved.
            Let us define a renormalization factor, $\renorm[mki]$, such that the renormalized track-length is given by
            \begin{equation}\label{eq:MOC:Track-Length Renormalization}
                \nsegl = \renorm[mki]\segl.
            \end{equation}
            The spatial integration schemes given by \cref{eq:MOC:Track-Averaged Definition UnRenormalized,eq:MOC:Spatial Averaging Definition UnRenormalized} become
            \begin{subequations}\label[subeqs]{eqs:MOC:Renormalized Spatial Integration Definition}
                \begin{equation}\label{eq:MOC:Renormalized Track-Averaged Definition}
                    \MOCTrackIntegral{f(\loc,\dirm)} \defined \frac{1}{\nsegl}\intl[0][\nsegl]f(\len,\dirm)\dif{\nlen},
                \end{equation}
                and
                \begin{equation}\label{eq:MOC:Renormalized Spatial Averaging Definition}
                    \MOCSingleAngleIntegral{f(\loc,\dirm)} \defined \frac{1}{V_i}\suml[k]\tA[mki]\nsegl\MOCTrackIntegral{f(\loc,\dirm)},
                \end{equation}
                where the spatial variable $\loc$ can now be written as a function of the renormalized track-distance, $\nlen$, as
                \begin{equation}\label{eq:MOC:Renormalized Location Variable}
                    \loc =  \locIn + \nlen\dirm / \renorm[mki],
                \end{equation}
                where $\locIn$ is the starting point of the track-segment.
            \end{subequations}

            Segment-volume preservation is a renormalization method in which the track-length is adjusted such that the analytic volume within the cross-sectional area of each track-segment is preserved.
            This renormalization technique is the most ``correct'' method of renormalization, but is very expensive as each track is renormalized separately.
            It is also more difficult to implement, as the analytic area of each track-segment must be found.
            To the best of our knowledge, this method is not implemented in any production-level \ac{MOC} code.

            Direction-volume preservation is the next ``most-correct'' renormalization technique.
            In this method, every mono-directional spatial integration should preserve the cell volume, i.e.
            \begin{equation}\label{eq:MOC:Angle-Volume Preservation}
                \MOCSingleAngleIntegral{1} = 1.
            \end{equation}
            This constraint leads to the renormalization factor given by
            \begin{equation}\label{eq:MOC:Direction-Dependent Renormalization}
                \renorm[mi] = \frac{V_i}{\suml[k]\tA[mki]\segl}.
            \end{equation}
            This method is significantly less expensive in terms of memory, computational time, and difficulty of implementation.

            The simplest renormalization technique, volume preservation, only preserves the volume over the spatial and directional integration, i.e.
            \begin{equation}\label{eq:MOC:Volume Preservation}
                \MOCIntegral{1} = \fourpi.
            \end{equation}
            This constraint leads to the renormalization factor given by
            \begin{equation}\label{eq:MOC:Region Renormalization}
                \renorm[i] = \frac{V_i}{\suml[m]\wt[m]\suml[k]\tA[mki]\segl}.
            \end{equation}

            Renormalization is not the only technique used for volume preservation.
            Another method is to use the numerical volume, $\suml[k]\tA[mki]\segl$ in place of $V_i$ in \cref{eq:MOC:Spatial Averaging Definition UnRenormalized}.
            This seems to be a more consistent method; however, a detailed comparison of these methods has not taken place, to the best of our knowledge.
            The renormalization technique generally seems to be the faster approach, and is the approach used in MPACT \cite{Collins2016}, which is used extensively in this work.
        }
    }
    \section{The Flat-Source Approximation}{\label{sec:MOC:FSA}
        The simplest approximation to the spatial shape of the source, $\source[mi][g][\loc]$, within each cell is the \acf{FSA}.
        The \ac{MOC} has been widely used in lattice physics and neutron transport codes \cite{Knott2010}, many of which have utilized the \ac{FSMOC} \cite{Halsall1980,Hong1998,Saji2000,Smith2002,Sugimura2006,Masiello2008,Boyd2014,Collins2016}.

        \subsection{Derivation}{\label{ssec:MOC:FSA:Derivation}
            The \ac{FSA} is simply the assumption that within each cell, $\Region$, the source, $\source[mi][g][\loc]$, is uniform.
            This can be expressed as
            \begin{equation}\label{eq:MOC:FSA:Source Shape}
                \source[mi][g][\loc] \approx \srcF[mi] = \srcF + \suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\srcF[i,\ell][g,n]
            \end{equation}
            To obtain a source in this form, \cref{eq:MOC:Source} requires that the region averaged scalar flux and higher-order angular moments (up to order $L$) be determined.
            In mathematical terms, the flat-source can be determined as
            \begin{equation}\label{eq:MOC:FSA:Source Computation}
                \srcF[mi] =
                    \left[
                        \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]\afluxmom[\gprime]
                        + \frac{\spect}{\keff}\suml[\gprime]\nufis\sflux[\gprime]
                    \right],
            \end{equation}
            where the $\sflux[\gprime]$ is the region-averaged scalar flux, and $\afluxmom[\gprime]$ are the region-averaged angular moments of the flux.

            In order to get these region-averaged flux moments, the spatial and directional integration operators, introduced in \cref{ssec:MOC:Track-Based Integration}, are used.
            \begin{subequations}\label[subeqs]{eqs:MOC:FSA:Region-Averaged Flux Moments Definition}
                The region-averaged scalar flux is given by
                \begin{equation}\label{eq:MOC:FSA:Region-Averaged Scalar Flux Definition}
                    \sflux = \MOCIntegral{\aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt[m]\suml[k]\nsegl\tA[mki]\MOCTrackIntegral{\aflux[][g][]},
                \end{equation}
                and the higher-order angular moments of the flux are given by
                \begin{equation}\label{eq:MOC:FSA:Region-Averaged Angular Moments of Flux Definition}
                    \afluxmom[g] = \MOCIntegral{\SH\aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt[m]\SH[\ell][n][\dirm]\suml[k]\nsegl\tA[mki]\MOCTrackIntegral{\aflux[][g][]}.
                \end{equation}
            \end{subequations}

            To evaluate these flux moments, the track-averaged angular flux, $\MOCTrackIntegral{\aflux[][g][]}$, must be found.
            By applying the \ac{FSA}, \cref{eq:MOC:MOC Equation Generic} becomes
            \begin{equation}\label{eq:MOC:FSA:Characteristic Form}
                \left[\deriv{}{\nlen} + \xst\right]\aflux[mki][g][\nlen] = \tsrcF[mi],
            \end{equation}
            where
            \begin{equation}
              \label{eq:MOC:FSA:Track Average Source}
              \tsrcF[mi] \defined \rfourpi\srcF[mi].
            \end{equation}
            This can be solved analytically for the angular flux along the track,
            \begin{subequations}\label[subeqs]{eqs:MOC:FSA:Angular Flux Solution}
                \begin{equation}\label{eq:MOC:FSA:Angular Flux Solution}
                    \aflux[mki][g][\nlen] = \afluxin + \left(\frac{\tsrcF[mi]}{\xst} - \afluxin\right)F_1(\opt),
                \end{equation}
                where
                \begin{equation}\label{eq:MOC:FSA:F1}
                    F_1(\opt) \defined 1 - \exp(-\opt),
                \end{equation}
                and $\opt$ is the (renormalized) optical thickness,
                \begin{equation}\label{eq:MOC:FSA:Optical Thickness}
                    \opt \defined \nlen\xst.
                \end{equation}
            \end{subequations}

            One approach to find $\MOCTrackIntegral{\aflux[][g][]}$, is to perform integration of \cref{eq:MOC:FSA:Angular Flux Solution} to evaluate the track-average value, resulting in
            \begin{equation}\label{eq:MOC:FSA:Track-Averaged Angular Flux Explicit}
                \MOCTrackIntegral{\aflux[][g][]} = \frac{\tsrcF[mi]}{\xst} - \left(\frac{\tsrcF[mi]}{\xst} - \afluxin\right)\frac{F_1(\segopt)}{\segopt}.
            \end{equation}
            This approach will be referred to as \emph{explicit}, as the moment's integral is explicitly evaluated.
            Another, approach, which in the author's opinion is simpler, is to use the track-averaging operator on the characteristic form of the transport equation, \cref{eq:MOC:FSA:Characteristic Form}, which simplifies to
            \begin{equation}\label{eq:MOC:FSA:Track-Averaged Angular Flux Implicit}
                \MOCTrackIntegral{\aflux[][g][]} = \frac{\tsrcF[mi]}{\xst} + \frac{\afluxin-\afluxout}{\segopt}.
            \end{equation}
            This approach will be referred to as \emph{implicit}, as the moment's integral is not explicitly evaluated.
            We note that the resulting forms of these two approaches are equivalent; by evaluating the outgoing flux in \cref{eq:MOC:FSA:Angular Flux Solution} at the outgoing position, \cref{eq:MOC:FSA:Track-Averaged Angular Flux Implicit} can be put into the form of \cref{eq:MOC:FSA:Track-Averaged Angular Flux Explicit}.
            By substituting the track-averaged angular flux in \cref{eqs:MOC:FSA:Region-Averaged Flux Moments Definition}, the flux moments can be evaluated, and used to compute the source.
            A transport calculation may be carried out using the source iteration algorithm defined by \cref{alg:NTT:Source Iteration}.
        }
        \subsection{Particle Conservation}{\label{ssec:MOC:FSA:Particle Conservation}
            The neutron transport equation, \cref{eq:NTT:Boltzmann Transport}, is a statement of particle balance within the defined phase-space.
            Previous works \cite{LeTellier2008,Ferrer2018} have examined the \ac{FSMOC} with respect to \emph{particle conservation}.
            \citet{LeTellier2008} defined necessary constraints on the directional quadrature and the characteristic tracks (trajectories) in order to ensure particle conservation for the anisotropic \ac{FSMOC}.
            The constraints can be found by requiring
            \begin{equation}\label{eq:MOC:FSA:Anisotropic Source Conservation}
                \rfourpi\MOCIntegral{\SH\srcF[mi]} = \srcF[i,\ell][g,n].
            \end{equation}
            Substituting \cref{eq:MOC:FSA:Source Shape} into \cref{eq:MOC:FSA:Anisotropic Source Conservation}, requires that
            \begin{subequations}\label[subeqs]{eqs:MOC:FSA:Anisotropic Constraints}
                \begin{equation}\label{eq:MOC:FSA:Quadrature Constraint}
                    \suml[m]\wt[m]\SH[\ell][n][\dirm]\SH[\ell'][n'][\dirm] = \delta_{\ell\ell'}\delta_{nn'},
                \end{equation}
                and
                \begin{equation}\label{eq:MOC:FSA:Track Constraint}
                    \suml[k]\nsegl\tA[mki] = V_i.
                \end{equation}
            \end{subequations}
            \Cref{eq:MOC:FSA:Quadrature Constraint} is a constraint on the directional quadrature, requiring orthogonality of the real spherical harmonics \cite{LeTellier2008}.
            \Cref{eq:MOC:FSA:Track Constraint} requires that \emph{at least} direction-dependent renormalization, \cref{eq:MOC:Direction-Dependent Renormalization}, be used.

            If the constraints on directional quadrature and characteristic tracks are satisfied, several simplifications to \cref{eqs:MOC:FSA:Region-Averaged Flux Moments Definition} are possible.
            \begin{subequations}\label[subeqs]{eqs:MOC:FSA:Region-Averaged Flux Moments}
                \begin{equation}\label{eq:MOC:FSA:Region-Averaged Scalar Flux}
                    \sflux = \frac{\srcF}{\xst} + \frac{\fourpi}{V_i\xst}\suml[m]\wt[m]\suml[k]\tA[mki]\dflux,
                \end{equation}
                \begin{equation}\label{eq:MOC:FSA:Region-Averaged Angular Moments of Flux}
                    \afluxmom[g] = \frac{\srcF[i,\ell][g,n]}{\xst} + \frac{\fourpi}{V_i\xst}\suml[m]\wt[m]\SH[\ell][n][\dirm]\suml[k]\tA[mki]\dflux,
                \end{equation}
                where
                \begin{equation}\label{eq:MOC:FSA:Delta Flux}
                    \dflux \defined \afluxin - \afluxout.
                \end{equation}
            \end{subequations}
        }
        \subsection{Isotropic Simplifications}{\label{ssec:MOC:FSA:Isotropic Simplifications}
            While anisotropic scattering is necessary for accurate calculations, it is also common for isotropic source calculations to be performed.
            Typically, these account for anisotropic behavior by using the \ac{TCP0} approximation \cite{YamamotoAnisotropy2008}.
            While not as accurate as truly anisotropic calculations, use of an isotropic source results in significantly fewer calculations, and allows for additional simplifications to be made.

            \Cref{eq:MOC:FSA:Anisotropic Source Conservation} is now only of concern for the isotropic component of the source.
            This results in the following constraint,
            \begin{equation}\label{eq:MOC:FSA:Isotropic Track Constraint}
                \suml[m]\wt[m]\suml[k]\nsegl\tA[mki] = V_i,
            \end{equation}
            which is equivalent to the direction-independent renormalization, given by \cref{eq:MOC:Region Renormalization}.
            These isotropic calculations become significantly less expensive, as only the scalar flux needs to be computed.
        }
        \subsection{Applications}{\label{ssec:FSA:Applications}
            The \ac{FSMOC} has been utilized in many \ac{MOC} production codes \cite{Halsall1980,Hong1998,Saji2000,Smith2002,Sugimura2006,Masiello2008,Boyd2014,Collins2016}.
            However, previous studies on the \ac{FSMOC} have found that a fine mesh must be used to obtain accurate results, particularly in the presence of control rods or blades, strong absorber rods, gadolinia poisoned fuel rods \cite{Petkov1999}, and large reflector regions (such as in critical experiments) \cite{Ferrer2016}.
            As the number of mesh elements increase, so does the number of track-segments (on which the \ac{MOC} computations are performed).
            This results in large run-times, and has motivated the development of \acfp{LSA} to the \ac{MOC}, that are discussed in detail in \cref{sec:MOC:LSA}.
        }
    }
    \section{The Linear-Source Approximation}{\label{sec:MOC:LSA}
        \subsection{Overview}{\label{ssec:MOC:LSA:Overview}
            The \acf{LSA}, in the \ac{MOC}, assumes the shape of the source along a characteristic track-segment is linear.
            There has long been motivation for the development of \acp{LSA} for the \ac{MOC}, as previous work \cite{Larsen1980} indicated that a spatially linear source was able to achieve faster computational performance in \ac{SN} calculations.
            There have been many different variants of this approximation.
            The first instance of the \ac{LSA} was the \emph{gradient source approximation} introduced by \citet{Halsall1993}.
            This early \ac{LSMOC} was based on the averaging of the angular flux gradient along tracks, and was implemented in the WIMS \cite{Halsall1993}, and PEACH \cite{Tang2009} \ac{MOC} transport codes.
            These averaged gradients were then used as estimates to the gradient of the scalar flux, which were used to compute the source shape as spatially linear.

            \citeauthor{Petkov1998} devised a \ac{LSA} that estimated the gradient of the scalar flux based on the $P_1$ approximation in the MARIKO code \cite{Petkov1998,Petkov1999}.
            In this approximation, the gradient of the scalar flux is computed from the neutron current, the total cross section, and the linearly anisotropic scattering matrix:
            \begin{equation}\label{eq:MOC:LSA:Current2Gradient}
                \grad\sflux \approx -3\left(\xst\current - \suml[\gprime]\xss[1]\current[i][\gprime]\right).
            \end{equation}
            A similar approach, using the diffusion approximation to compute the scalar flux gradient, was used in the so called ``quasi-linear'' source implemented by \citet{Rabiti2009}.
            In this approach, the $\xss[1]$ matrix is diagonalized, turning the $P_1$ approximation into the diffusion approximation.
            Due to their basis on the $P_1$ and diffusion approximations, these early \acp{LSA} are inaccurate in situations where more transport-like effects are present.
            It can be shown, even in simple cases, that this approximation can be predict the opposite direction for the scalar flux gradient.
            % NOTE[show TCP0 work here?]

            \citet{Santandrea2002} introduced the positive linear and nonlinear surface characteristics scheme, which constructed a linear source by interpolating between source values on the surfaces of cell regions.
            Various improvements have been made to this surface characteristics scheme for conservation \cite{Santandrea2002}, as well as coupling in APOLLO2 \cite{Santandrea2008}.
            \citet{LeTellier2006} introduced a simplification to the linear characteristics scheme for conservation, by using a diamond-differencing scheme.
            This work was extended by \citet{Hebert2016}, to include higher-order diamond difference schemes, as well as allowing for acceleration \cite{Hebert2017}.

            The most recent \ac{LSA} examined in this work was introduced as a 2-D general high-order method for unstructured meshes by \citet{Masiello2009}.
            The approximation uses track-based integration, defined in \cref{ssec:MOC:Track-Based Integration}, in order to compute spatial moments of the angular flux.
            This \ac{LSA} was shown to reduce memory and computation times in 3-D \ac{MOC} calculations \cite{Chai2009}.
            The general method was simplified in the case of the isotropic and anisotropic \ac{LS} by \citet{Ferrer2016}; this also introduced the ``LS-P0'' method in which the isotropic source is spatially linear, but the anisotropic source components are spatially uniform within each cell.
            This \ac{LSA} was also shown to be consistent with particle conservation, under certain constraints, and to be compatible with \ac{CMFD} acceleration \cite{Ferrer2018}.

            This thesis work has made extensive use of this \ac{LSA}, and has made improvements upon the method.
            For this reason, in the following section the formulation prior to the work of this thesis is derived.
        }
        \subsection{Derivation}{\label{ssec:MOC:LSA:Derivation}
            The moment-based \ac{LSA} assumes the shape of the source, $\source[mi][g][\loc]$, is spatially linear within each cell, $\Region$.
            This can be expressed as
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Source Shape}
                \begin{equation}\label{eq:MOC:LSA:Source Shape}
                    \source[mi][g][\loc] \approx \srcF[mi] + \loc\vdot\srcL[][mi],
                \end{equation}
                where $\srcL[][mi]$ is a column vector of source spatial expansion coefficients,
                \begin{equation}
                    \srcL[][mi] \defined\begin{bmatrix}\srcL[x][mi]\\\srcL[y][mi]\\\srcL[z][mi]\end{bmatrix},
                \end{equation}
                and $\loc$ is the position in \emph{local} coordinates.
            \end{subequations}
            A similar spatial expansion of the angular moments of the flux can be performed,
            \begin{equation}\label{eq:MOC:LSA:Flux Expansion}
                \fluxA(\loc) = \fluxF + \loc\vdot\fluxL,
            \end{equation}
            the source can then be expressed as
            \begin{equation}\label{eq:MOC:LSA:Linear Source Computation}
                \source[mi][g][\loc]
                    = \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]\fluxA[\gprime](\loc)
                    + \frac{\spect}{\keff}\suml[\gprime]\nufis\sflux[\gprime](\loc),
            \end{equation}
            and the linear expansion coefficients are explicitly given by
            \begin{equation}\label{eq:MOC:LSA:Linear Source Coefficients}
                \srcL[][mi]
                    = \suml[\gprime]\suml[\ell=0][L]\suml[n=-\ell][\ell]\SH[\ell][n][\dirm]\xss[\ell]\fluxL[\gprime]
                    + \frac{\spect}{\keff}\suml[\gprime]\nufis\sfluxL[\gprime].
            \end{equation}

            In the spatial moment-base \ac{LSA}, it is convenient to define the spatially linear source (and flux) in terms of a cell-local coordinate system.
            We allow $\Loc$ to be the position variable in the global coordinate system, the local coordinates are then defined as
            \begin{equation}\label{eq:MOC:LSA:Global to Local Coordinates}
                \loc = \Loc - \centroid[\Loc][mi],
            \end{equation}
            where $\centroid[\Loc][mi]$ is the numerical centroid of the cell $i$.

            These numerical centroids can be defined as either direction-dependent, or direction-independent, which will have implications on particle conservation, as is discussed in \cref{ssec:MOC:LSA:Particle Conservation}.
            The direction-dependent centroids are defined by
            \begin{equation}\label{eq:MOC:LSA:Direction-Dependent Centroids}
                \centroid[\Loc][mi] \defined \MOCSingleAngleIntegral{\Loc} = \frac{1}{V_i}\suml[k]\tA[mki]\nsegl\locCent[\Loc],
            \end{equation}
            where $\locCent[\Loc]$ is the global coordinate vector of the track-segment mid-point.
            Similarly, the direction-independent centroids are defined by
            \begin{equation}\label{eq:MOC:LSA:Direction-Independent Centroids}
                \centroid[\Loc][i] \defined \rfourpi\MOCIntegral{\Loc} = \frac{1}{V_i}\suml[m]\wt\suml[k]\tA[mki]\nsegl\locCent[\Loc].
            \end{equation}

            Following the same approach as the \ac{FSMOC} derivation, in \cref{ssec:MOC:FSA:Derivation}, computing the source requires the region-averaged flux moments, $\fluxF$, and the flux expansion coefficients, $\fluxL$.
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions}
                The region-averaged flux moment can be found using the same definition as previously,
                \begin{equation}\label{eq:MOC:LSA:Region-Averaged Flux Moment Definition}
                    \fluxF \defined \MOCIntegral{\SH \aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\MOCTrackIntegral{\aflux[][g][]}.
                \end{equation}
                In order to determine the spatial expansion coefficients of the flux moments, \cref{eq:MOC:LSA:Flux Expansion} is operated on by $\MOCIntegral{\SH\loc(\vdot)}$.
                Recognizing that this should be directly proportional to angular flux operated on by $\MOCIntegral{\SH\loc\aflux[][g][]}$, a system of equations is found
                \begin{equation}\label{eq:MOC:LSA:Moment to Expansion Coefficient}
                    \M\fluxL = \MOCIntegral{\SH\loc\aflux[][g][]},
                \end{equation}
                where
                \begin{equation}\label{eq:MOC:LSA:Geometric Moments}
                    \M \defined \MOCIntegral{\loc^T\loc}.
                \end{equation}
                The spatial angular flux moments, $\MOCIntegral{\SH\loc\aflux[][g][]}$, are then defined as
                \begin{equation}\label{eq:MOC:LSA:Revion-Averaged Spatial Angular Flux Moments Definition}
                    \MOCIntegral{\SH\loc\aflux[][g][]} = \frac{\fourpi}{V_i}\suml[m]\wt\SH[\ell][n][\dirm]\suml[k]\tA[mki]\nsegl\left(\locIn\MOCTrackIntegral{\aflux[][g][]} + \dirm\MOCTrackIntegral{\nlen\aflux[][g][]} / \renorm[mi]\right).
                \end{equation}
            \end{subequations}

            In order to evaluate the flux moments defined in \cref{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions}, the track-averaged angular flux values, $\MOCTrackIntegral{\aflux[][g][]}$, and $\MOCTrackIntegral{\nlen\aflux[][g][]}$, must be determined.
            First, the transport equation must be put into characteristic form, using \cref{eq:MOC:Renormalized Location Variable} the spatially expanded source, \cref{eq:MOC:LSA:Source Shape}, can be defined along the characteristic.
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Characteristic Form}
                The characteristic transport equation becomes
                \begin{equation}\label{eq:MOC:LSA:Characteristic Form}
                    \left[\deriv{}{\nlen} + \xst\right]\aflux = \tsrcF + \tsrcL\left(\nlen - \frac{\nsegl}{2}\right),
                \end{equation}
                where
                \begin{equation}\label{eq:MOC:LSA:Track Average Source}
                    \tsrcF \defined \rfourpi\left[\srcF[mi] + \locCent \vdot \srcL[][mi]\right],
                \end{equation}
                \begin{equation}\label{eq:MOC:LSA:Track Linear Source}
                    \tsrcL \defined \rfourpi\left[\frac{\dirm\vdot\srcL[][mi]}{\renorm[mi]}\right],
                \end{equation}
                and $\locCent$ is the local-coordinate centroid of the track-segment.
            \end{subequations}
            Substituting this assumed source shape (linear) into the generic \ac{MOC} solution, given by \cref{eq:MOC:MOC Generic Solution}, the angular flux along a track-segment is found to be
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Angular Flux Solution}
                \begin{equation}\label{eq:MOC:LSA:Angular Flux Solution}
                    \aflux = \afluxin + \left(\frac{\tsrcF}{\xst} - \afluxin\right)F_1(\opt) + \frac{\tsrcL}{2(\xst)^2}F_2(\opt),
                \end{equation}
                where
                \begin{equation}\label{eq:MOC:LSA:F1}
                    F_1(\opt) \defined 1 - \exp(-\opt),
                \end{equation}
                and
                \begin{equation}\label{eq:MOC:LSA:F2}
                    F_2(\opt) \defined 2[\opt-F_1(\opt)] - \segopt F_1(\opt).
                \end{equation}
            \end{subequations}

            As discussed in \cref{ssec:MOC:FSA:Derivation}, there are two \emph{equivalent} methods with which one could determine the track-averaged angular flux values.
            The original derivation of the \ac{LSA} method by \citet{Ferrer2016} used the \emph{implicit} definition for the track-average angular flux, but the \emph{explicit} definition for the first spatial moment of the angular flux.
            In \cref{ch:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}, the implicit definition is taken for the first spatial moment of the angular flux as well, which allows for additional improvements for the method in multi-physics and 2D/1D applications.
            For the remainder of this section, the formulation as it was originally derived by \citet{Ferrer2016} is shown, using the explicit form of $\MOCTrackIntegral{\nlen\aflux[][g][]}$.

            The implicitly defined track-average flux is given by operating on \cref{eq:MOC:LSA:Characteristic Form} by $\MOCTrackIntegral{(\vdot)}$, and the explicitly defined first spatial moment of the angular flux is given by operating on \cref{eq:MOC:LSA:Angular Flux Solution} by $\MOCTrackIntegral{\nlen(\vdot)}$.
            These are shown in \cref{eqs:MOC:LSA:Track-Averaged Moments}.
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Track-Averaged Moments}
                \begin{equation}\label{eq:MOC:LSA:Track-Averaged Angular Flux}
                    \MOCTrackIntegral{\aflux[][g][]} = \frac{\tsrcF}{\xst} + \frac{\dflux}{\segopt},
                \end{equation}
                and
                \begin{equation}\label{eq:MOC:LSA:Track-Averaged Linear Angular Flux}
                    \MOCTrackIntegral{\nlen\aflux[][g][]} =
                      \afluxin\frac{\nsegl}{2} + \left(\frac{\tsrcF}{\xst} - \afluxin\right)\frac{G_1(\segopt)}{\xst}
                      + \frac{\tsrcL}{2(\xst)^2}\nsegl G_2(\segopt).
                \end{equation}
            \end{subequations}
            Here
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:G Functions}
              \begin{equation}\label{eq:MOC:LSA:G1}
                  G_1(\segopt) \defined 1 + \frac{\segopt}{2} - \left(1+\frac{1}{\segopt}\right)F_1(\segopt),
              \end{equation}
              and
              \begin{equation}\label{eq:MOC:LSA:G2}
                  G_2(\segopt) \defined \frac{2}{3}\segopt - \left(1+\frac{2}{\segopt}\right)G_1(\segopt).
              \end{equation}
            \end{subequations}

            % Ferrer & Rhodes derivation
            The original derivation further simplified \cref{eqs:MOC:LSA:Region-Averaged Flux Moments Definitions} into the following forms.
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Region-Averaged Flux Moments}
                \begin{equation}\label{eq:MOC:LSA:Region-Averaged Angular Moments}
                    \fluxF = \frac{\fourpi}{\xst V_i}\suml[m]\wt[m]\SH[\ell][n][\dirm] \xst \FerrerFlatPsi,
                \end{equation}
                \begin{equation}\label{eq:MOC:LSA:Region-Averaged Spatial Moments}
                  \MOCIntegral{\loc\SH\aflux[][g][]} = \frac{\fourpi}{\xst V_i}\suml[m]\wt[m]\SH[\ell][n][\dirm] \xst \left(\FerrerLinearPsi + \dirm\FerrerLinearPsiHat/\renorm\right),
                \end{equation}
            \end{subequations}
            where
            \begin{subequations}{\label[subeqs]{eqs:MOC:LSA:Ferrer Psis}}
                \begin{equation}\label{eq:MOC:LSA:Ferrer Flat Psi}
                    \FerrerFlatPsi \defined
                      \frac{1}{\xst}\left[
                          \frac{\srcF[mi]}{\fourpi}\suml[k]\tA\nsegl
                        + \frac{\srcL[][mi]}{\fourpi}\vdot\suml[k]\tA\locCent\nsegl
                        + \suml[k]\tA\dflux
                      \right],
                \end{equation}
                \begin{equation}\label{eq:MOC:LSA:Ferrer Linear Psi}
                  \begin{aligned}
                    \FerrerLinearPsi \defined
                      \frac{1}{\xst}\Bigg[
                          &\left(\suml[k]\tA\nsegl\locIn\right)\frac{\srcF[mi]}{\fourpi}
                        + \left(\suml[k]\tA\nsegl\locIn(\locCent)^T\right)\frac{\srcL[][mi]}{\fourpi}\\
                        &+ \suml[k]\tA\locIn\dflux
                      \Bigg],
                  \end{aligned}
                \end{equation}
                and
                \begin{equation}\label{eq:MOC:LSA:Ferrer Linear PsiHat}
                    \FerrerLinearPsiHat \defined
                      \frac{1}{\xst}\left[
                          \frac{\srcF[mi]}{\fourpi}\FerrerAnisotropicFlatC
                         +\frac{\srcL[][mi]}{\fourpi}\vdot\FerrerAnisotropicLinearC
                         +\suml[k]\tA\nsegl\afluxin H(\segopt)
                      \right],
                \end{equation}
            \end{subequations}
            where
            \begin{subequations}
              \begin{equation}\label{eq:MOC:LSA:Ferrer Ansitropic Flat C}
                \FerrerAnisotropicFlatC \defined
                  \frac{1}{\xst}\suml[k]\tA\nsegl G_1(\segopt),
              \end{equation}
              \begin{equation}\label{eq:MOC:LSA:Ferrer Ansitropic Linear C}
                \FerrerAnisotropicLinearC \defined
                  \frac{1}{\xst}\suml[k]\tA\nsegl\left(
                      \locCent G_1(\segopt) + \dirm\frac{\segl}{2}G_2(\segopt)
                  \right),
              \end{equation}
            \end{subequations}
            and
            \begin{equation}\label{eq:MOC:LSA:H Function}
              H(\segopt) \defined \frac{\segopt}{2} - G_1(\segopt).
            \end{equation}

            The $\FerrerAnisotropicFlatC$ and $\FerrerAnisotropicLinearC$ are dependent on both the energy group, $g$, and direction $m$, for each region, $i$.
            If these terms are stored, this leads to considerable memory usage, and will often use more memory than the flux moments that are of interest.
            If cross sections are constant in the problem (no feedback, or 2D/1D transverse leakage splitting), these coefficients can be pre-computed once at the outset of the simulation.
            If this is not the case, these coefficients must be re-evaluated each time there is a change in cross sections.
            The re-evaluation of these coefficients can lead to significant overhead.
            In cases with \ac{TH} feedback, cross sections typically change each iteration.
        }
        \subsection{Particle Conservation}{\label{ssec:MOC:LSA:Particle Conservation}
            When considering particle conservation, use of the \ac{LSA} results in additional constraints on the calculations.
            Similarly to \cref{ssec:MOC:FSA:Particle Conservation}, the track-based integration of the source must exactly integrate to the spatial and angular moments of the source.
            The conservation of spatial moments is the basis of this \ac{LSA} \cite{Ferrer2018}, so this constraint is satisfied without additional constraints on the method.
            The angular moment constraint is expressed as
            \begin{equation}\label{eq:MOC:LSA:Angular Moment Constaint}
                \rfourpi\MOCIntegral{\SH\source[mi][g][\loc]} = \srcF[i,\ell][g,n].
            \end{equation}
            In addition to the constraints introduced in \cref{ssec:MOC:FSA:Particle Conservation}, namely direction-dependent renormalization, and directional quadrature restrictions, there is a constraint on the definition of the local coordinate system:
            \begin{equation}\label{eq:MOC:LSA:Anisotropic Coordinate Constraint}
                \MOCSingleAngleIntegral{\loc} = 0.
            \end{equation}
            This is equivalent to stating that the local coordinate system must be defined with respect to direction-dependent global centroids, as is given by \cref{eq:MOC:LSA:Direction-Dependent Centroids}.
        }
        \subsection{Isotropic Simplifications}{\label{ssec:MOC:LSA:Isotropic Simplifications}
            \citet{Ferrer2016} suggested that allowing only the flat source components to consider anisotropic scattering has performance benefits, while not significantly affecting accuracy.
            It was demonstrated for the \acf{BandW} experiments \cite{Hoovler1980} that considering anisotropic scattering only with spatially flat flux moments resulted in approximately 10 pcm error.
            Furthermore, by making this simplification, run-times were reduced significantly (up to 45\%), while memory savings were even more significant (up to 89\%) \cite{Ferrer2016}.

            As stated in \cref{ssec:MOC:FSA:Isotropic Simplifications}, it is very common in reactor simulations to use \ac{TCP0} cross-sections (which are isotropic).
            Assuming isotropic scattering, \cref{eqs:MOC:LSA:Region-Averaged Flux Moments} become
            \begin{subequations}\label[subeqs]{eqs:MOC:LSA:Isotropic Region-Averaged Flux Moments}
              \begin{equation}\label{eq:MOC:LSA:Isotropic Scalar Flux}
                \sflux = \frac{\srcF}{\xst} + \frac{\fourpi}{\xst V_i}\suml[m]\wt[m]\suml[k]\tA\dflux,
              \end{equation}
              \begin{equation}\label{eq:MOC:LSA:Isotropic Spatial Moments of Flux}
                \MOCIntegral{\loc\aflux[][g][]} =
                    \C\frac{\srcL}{\xst}
                  + \frac{\fourpi}{\xst V_i}\suml[m]\wt\suml[k]\tA\left[
                        \locIn\dflux + \dirm\segl\afluxin H(\segopt)
                    \right],
              \end{equation}
            \end{subequations}
            where
            \begin{equation}\label{eq:MOC:LSA:C Matrix}
              \C \defined
                \frac{1}{\xst V_i}\suml[m/2]\wt\suml[k]\tA\dirm\dirm^{T}\segl^2G_2(\segopt)
                + \frac{2}{V_i}\suml[m/2]wt\suml[k]\tA\loc\loc^T\nsegl.
            \end{equation}

            These $\C$ coefficients are no longer dependent on the direction, but still require significant memory usage.
            They require more memory than the scalar flux coefficients.
            If cross sections are not constant through the simulation, the previously mentioned inefficiencies are still present.
        }
        \subsection{Applications}{\label{ssec:MOC:LSA:Applications}
            Various different \acp{LSA} to the \ac{MOC} have been developed and implemented in transport codes \cite{Halsall1993,Petkov1999,Santandrea2002,Tang2009,Rabiti2009,Boyd2014,Ferrer2016,Fitzgerald2018}.
            Results have indicated that by using a \ac{LSA}, the spatial mesh discretization can be made coarser, relative to the \ac{FSA}, while maintaining transport accuracy.
            Although each segment calculation is more expensive when using a \ac{LSA}, the number of calculations (due to the coarser spatial mesh) can be significantly reduced, leading to reduced run-times.
            Additionally, the reduction in spatial mesh elements generally reduces the amount of memory required by the calculation.
        }
    }

    \section{Ray-Tracing}{\label{sec:MOC:Ray-Tracing}
      The \acf{MOC} \cite{Askew1972} is based on solving the transport equation along many characteristic tracks or rays.
      These rays are followed through the reactor geometry in a process generally referred to as ``ray-tracing''.
      The placement and storage of these tracks is significant with respect to both calculation accuracy as well as computational performance.
      This section serves to give an overview of the current state-of-the-art ray-tracing methods used for \ac{MOC}-like transport calculations.

      \subsection{Fundamentals}{\label{ssec:MOC:RT:Fundamentals}
        This section covers the fundamentals of why ray-tracing is necessary for \ac{MOC} calculations, what data is necessary, and possible constraints.
        Unless a neutron has an interaction with surrounding media, it will travel in a straight line.
        This idea is represented in the characteristic form of the transport equation (\cref{eq:MOC:MOC Equation Generic}), which follows a generic characteristic through the problem domain.
        The \ac{MOC} is based on solving the \cref{eq:MOC:MOC Equation Generic} along many of these characteristic paths, performing spatial/directional integrations using \cref{eqs:MOC:Renormalized Spatial Integration Definition}.

        For a \ac{MOC} iteration, it is necessary to compute the integrated quantities of the angular flux (\cref{eqs:MOC:FSA:Region-Averaged Flux Moments,eqs:MOC:LSA:Region-Averaged Flux Moments}).
        This requires that the angular flux along a track-segment, the path-segment of a characteristic path bounded within a spatial cell, is known.
        Determining the angular flux along a track-segment (\cref{eq:MOC:MOC Generic Solution}) can be done only if the incident angular flux is known, and the length of the track-segment is known.
        Generally, characteristic paths will not be constructed independently for each spatial cell because then the incident flux on the surface would need to be approximated.
        Thus, a long characteristic path (ray) is generated to pass through the domain (or sub-system of the domain), and the lengths of each segment (bounded by spatial cells) are recorded.
        This way, given the incident flux at one end of the characteristic ray, the ray can be followed and the angular flux can be determined for each segment of the ray.
        Because the incident flux of one segment is the outgoing flux of the previous segment, the segments must be ``swept'' in order.
      }

      \subsection{Modular Ray-Tracing}{\label{ssec:RT:Modular Ray-Tracing}
        The most straight-forward approach to perform a \ac{MOC} calculation is to create rays that span the domain of the transport problem being solved.
        However, in this approach, the information of each ray-segment must be stored, or computed on-the-fly.
        In large problems the number of ray-segments can become exceedingly large, and this approach is not feasible due to memory constraints.

        This led to the development of so-called ``modular'' ray-tracing methods \cite{Filippone1980,Saji2000,Wu2003,Kochunas2013}, in which the regularity of reactor designs is utilized to reduce memory requirements.
        In typical reactor designs, certain geometries (like assemblies) are repeated throughout the core.
        Rather than laying tracks down for the global geometry, the transport problem is partitioned into ``modules'' that represent small often-repeated geometries in the problem.
        The ray-tracing data is generated for each module, in such a way there is direct linking of tracks on module interfaces; this is the \ac{DNPL} technique devised by \citet{Saji2000}.
        This significantly reduces the amount of ray-tracing data that needs to be stored in \ac{MOC} calculations, and has been widely adopted in \ac{MOC} transport codes \cite{Hong1998,Jung2009,Tang2009,DeCART,APOLLO3,MPACT2016,Hebert2017a}.
        Tracks spanning the global domain are then constructed by connecting multiple modular rays, as is depicted in \cref{fig:MRT:Modular Ray Tracing}.

        \begin{figure}[h]
            \centering
            \def\svgwidth{0.4\linewidth}
            \input{\figpath/ModularRayTracing.pdf_tex}
            \caption{Depiction of modular ray-tracing method. Global (long) rays can be constructed by connecting multiple modular rays, as is shown in red.}
            \label{fig:MRT:Modular Ray Tracing}
        \end{figure}

        The modular ray-tracing technique, with \ac{DNPL}, requires that the number of tracks on a modular boundary be an integer.
        This additionally requires that all modules have the same spatial dimensions, given by the pitches $P_x$ and $P_y$, and that the spacing between all tracks in a direction are constant.
        Let $\tA[a0]$ be the desired ray-spacing for an azimuthal angle $a$, and $\Azimuthal_{a0}$ be the desired azimuthal angle.
        The number of rays on the $x$ and $y$ module boundaries can be determined as
        \begin{subequations}\label[subeqs]{eqs:MRT:Nx/y}
            \begin{equation}\label{eq:MRT:Nx}
                N_x = \ceil*{\frac{P_x \sin(\Azimuthal_{a0})}{\tA[a0]}},
            \end{equation}
            and
            \begin{equation}\label{eq:MRT:Ny}
                N_y = \ceil*{\frac{P_x \cos(\Azimuthal_{a0})}{\tA[a0]}}.
            \end{equation}
        \end{subequations}
        The $x$ and $y$ distance between rays is then determined by
        \begin{subequations}\label[subeqs]{eqs:MRT:x/y ray-spacing}
            \begin{equation}\label{eq:MRT:x ray-spacing}
                \delta_x = \frac{P_x}{N_x},
            \end{equation}
            and
            \begin{equation}\label{eq:MRT:y ray-spacing}
                \delta_y = \frac{P_y}{N_y}.
            \end{equation}
        \end{subequations}
        The azimuthal angle is then ``corrected'' to represent the true angle at which the rays are placed,
        \begin{equation}\label{eq:MRT:Azimuthal Correction}
            \Azimuthal_{a} = \tan^{-1}\!\left(\frac{\delta_y}{\delta_x}\right),
        \end{equation}
        and the corrected ray-spacing is then given by
        \begin{equation}\label{eq:MRT:Corrected Radial Ray-Spacing}
            \tA[a] = \delta_x \sin(\Azimuthal_{a}).
        \end{equation}
        Another approach that has been taken in MPACT is to use a rational fraction to approximate $\tan(\frac{\delta_y}{\delta_x})$.

        Due to the constraint of \ac{DNPL}, the directional quadrature is perturbed in the process of ray-tracing.
        As described in \cref{ssec:MOC:FSA:Particle Conservation}, this has implications on particle conservation in calculations.
        In order to maintain accuracy, it may become necessary to use a higher-order directional quadrature than would have been necessary if the directions were not perturbed by \ac{MRT}.
      }

      \subsection{Mobile Chords}{\label{ssec:RT:Mobile Chords}
        The mobile chord method was introduced by \citet{Villarino1992} in the HELIOS code for \ac{CP} calculations, and adapted to the \ac{MOC} by \citet{Yamamoto2008}.
        In the typical equidistant ray-tracing method, a ray is placed at the center of the ray-width.
        The mobile chord method offsets the ray from the center, with differing offsets in each direction.
        The offset is typically a fraction of the ray width that increases linearly with the azimuthal angle index.
        This has generally shown to be more accurate than the typical equidistant ray-tracing method \cite{Yamamoto2008}, but is not directly compatible with the \ac{DNPL} technique.
        While ray widths are still linked, the ray-traces are not; though, this does not seem to introduce significant discretization errors \cite{Yamamoto2008}.
        An example illustration of mobile chords is given in \cref{figs:RT:MobileChords}.

        \begin{figure}[h]
          \centering
          \begin{subfigure}[t]{0.45\textwidth}
            \centering
            \def\svgwidth{0.85\textwidth}
            \input{\figpath/MobileChords/EquidistantRaySpacing.pdf_tex}
            \caption{Centered Chords\label{fig:RT:MobileChords:Normal}}
          \end{subfigure}%
          ~
          \begin{subfigure}[t]{0.45\textwidth}
            \centering
            \def\svgwidth{0.85\textwidth}
            \input{\figpath/MobileChords/MobileChords.pdf_tex}
            \caption{Mobile Chords\label{fig:RT:MobileChords:MobileChords}}
          \end{subfigure}
          \caption{Example illustration of centered chords (traditional approach) and mobile chords for a single direction.\label{figs:RT:MobileChords}}
        \end{figure}
      }

      \subsection{Random Rays}{\label{ssec:RT:Random Rays}
        The random ray method was developed in the ARRC code by \citet{Tramm2018}, and is a hybrid method between Monte Carlo and \ac{MOC} methods.
        This ray-tracing method uses stochastic discretizations of the directions and space (characteristic rays).
        The method uses a unique directional quadrature and ray-trace each iteration; this significantly decreases the memory usage, as tracking storage is completely eliminated.
        The use of random rays on boundaries also allows for the storage of boundary/interface flux to be eliminated entirely; this is due to the consideration of cyclic-tracks, and cancellation of errors due to stochastic ray placement \cite{Tramm2018}.

        This also significantly increases the amount of work that needs to be done for each track, as intersection data needs to be recomputed for each track each iteration.
        There are claims that the cache benefits of not storing the rays out-weighs the increased computational work \cite{Tramm2018}.
        Initial results for this method have been promising, but no \ac{CMFD} acceleration for this method has been utilized at this time.
      }

      \subsection{Macroband}{\label{ssec:RT:Macroband}
        The \emph{macroband} method  was originally proposed by \citet{Villarino1992} for \ac{CP} calculations in HELIOS.
        In this method, characteristic rays placed within ``macrobands'' are separated by tangential and intersection points in the mesh.
        There is no material or geometric discontinuities within each macroband segment (macrosegment), thus the direction-of-flight averaged angular flux in each macrosegment is smooth with regards to the transverse direction.
        Since integration in the \ac{MOC} is akin to a quadrature integration, this indicates that a more advanced quadrature, for ray placement and width, can be used to reduce discretization error \cite{Yamamoto2005}.

        \begin{figure}[h]
          \centering
          \begin{subfigure}[t]{0.45\linewidth}
            \centering
            \def\svgwidth{0.85\linewidth}
            \input{\figpath/EquidistantRaySpacing.pdf_tex}
            \caption{Equidistant}
          \end{subfigure}%
          ~
          \begin{subfigure}[t]{0.45\linewidth}
              \centering
            \def\svgwidth{0.85\linewidth}
            \input{\figpath/MacroBandRays.pdf_tex}
            \caption{Macroband}
          \end{subfigure}
          \caption{Visualization of hypothetical tracks for (a) equidistant and (b) macroband ray-tracing methods. Boundaries between macrobands are shown as red dotted lines.}
          \label{fig:RT:Equidisant vs Macroband}
        \end{figure}

        The \ac{MRT} ray-tracing technique does not consider the internal geometry when laying down tracks.
        For a specified ray-spacing and module size, the tracks are the same regardless of the internal mesh.
        The macroband takes an entirely different approach, and the internal mesh is the primary guide for laying down the tracks.

        Macrobands are determined by the computational mesh; for large heterogeneous assemblies, this results in very thin macrobands, which would result in significantly increased computation time.
        In the related \acf{CDP} \citet{Hong1999} proposed that macroband ray-tracing data only be generated on unique subsystems.
        Similarly, \citet{Yamamoto2005} proposed the \ac{MRMB} in which macroband ray-tracing data is only generated for unit-cells.
        These techniques are similar to the modular ray-tracing technique in that ray-tracing data is only generated for unique subsystems, which significantly reduces the amount of ray-tracing data.
        The macroband ray-tracing process is displayed for a single pin-cell mesh in \cref{fig:RT:Macroband Process}.

        \begin{figure}[!ht]
          \centering
          \begin{subfigure}[t]{0.33\linewidth}
            \centering
            \def\svgwidth{0.95\linewidth}
            \input{\figpath/MacroBandProcess1.pdf_tex}
            \caption{Determine intersection and tangent points}
          \end{subfigure}%
          \hfill
          \begin{subfigure}[t]{0.33\linewidth}
            \centering
            \def\svgwidth{0.95\linewidth}
            \input{\figpath/MacroBandProcess2.pdf_tex}
            \caption{Determine macroband boundaries (through identified points)}
          \end{subfigure}%
          \hfill
          \begin{subfigure}[t]{0.33\linewidth}
            \centering
            \def\svgwidth{0.95\linewidth}
            \input{\figpath/MacroBandProcess3.pdf_tex}
            \caption{Perform ray-tracing within macroband boundaries}
          \end{subfigure}
          \caption{Ray-tracing process for macroband.}
          \label{fig:RT:Macroband Process}
        \end{figure}

        However, these techniques are fundamentally incompatible with the \ac{DNPL} technique, thus an approximation of angular flux must be made on subsystem interfaces.
        \citet{Yamamoto2005} proposed linearly interpolating the angular flux on cell boundaries, though other techniques involving averaging the angular flux on sub-boundaries have been utilized in the \ac{CDP} \cite{Liu2014}.
        Additionally, these methods do not require adjustment to the angular quadrature.

        \citet{Yamamoto2005} found that the macroband method (using a Gauss-Legendre quadrature for ray placement), was more accurate than conventional ray-tracing methods with equidistant ray-spacing.
        \citet{Fevotte2007} proposed a new tracking technique similar to the macroband method, in which rays (placed equidistantly) are divided into sub-bands, which are effectively \emph{locally} projected macrobands, and the average flux of the sub-bands is propagated along each ray.
        Studies of ray-spacing with macroband, and \citetp{Fevotte2007} method, have indicated that coarser ray-spacing can be used while maintaining accuracy \cite{Yamamoto2005,Fevotte2007,Yamamoto2008}.

        \subsubsection{Interface Flux Approximations}{\label{sssec:RT:Interface Flux Approximations}
          The macroband ray-tracing method is fundamentally incompatible with \acf{DNPL}; therefore, it requires an approximation at the subsystem interfaces.
          Although ray-tracing can be performed on small unique subsystems, similarly to the \ac{MRT} method, the rays on module interfaces are no longer guaranteed to align.
          This makes it necessary for an approximation of the spatial dependence of the angular flux on these interfaces.
          However, there are multiple different options for performing this approximation.

          \citet{Yamamoto2005} proposed performing a linear of the flux on these interfaces.
          However, without adjustment, linear interpolation will not preserve the total flux passing through the surface; which is an important aspect when considering acceleration techniques such as \ac{CMFD}.
          For 3-D \ac{CDP} with uniformly spaced rays, \citet{Liu2014} proposed a sub-boundary averaging method.
          This method partitioned each interface into sub-boundaries, with the size depending on the interface and the direction; each sub-boundary represented a single angular flux value for each energy group, that was the average of the angular flux of all rays with centroids that intersected the sub-boundary.
          However, because only the centroids of each ray are considered using ray-spacing that is coarse compared to the sub-boundary size it not feasible.

          An earlier work \cite{Hong1999} used a similar 2-D sub-boundary averaging (though not directionally dependent); but rather than only considering the ray centroids, it considered the ``projection'' of rays.
          The ``projection'' being the area on the surface which would be intersected by the ray if it were infinite in length.
          Then, partial intersections of the projection and sub-boundaries are considered.
          This allows for coarse ray-spacing to be used without as much accuracy on the interfaces as the previously mentioned method.

          \Cref{fig:RT:2D SubBoundarySurfaceFlux} visually depicts the surface projections of 2-D rays on a single surface.
          This figure will be used as an example for the equations of this sub-boundary averaging method.
          $\psi_s^1$ should be a linear combination of the ray fluxes $\psi_r^1$ and $\psi_r^2$, based on their fractional areas, $A_1^1$ and $A_2^1$, respectively.
          Let us denote a sub-boundary as $S_i$ where $i$ is some index, and a ray projection as $R_j$ where $j$ is some index.
          We expect the surface flux to be a linear combination of the ray fluxes that intersect it; this can be expressed mathematically as
          \begin{equation}\label{eq:RT:SubBoundary Flux}
            \psi_s^i = \suml[j] \frac{A(S_i\cap R_j)}{A(S_i)}\psi_r^j,
          \end{equation}
          where $A$ denotes a function returning the area of the argument, and $\cap$ indicates the intersection of two objects.
          To show that this preserves the leakage through the surface, consider
          \begin{aequation}\label{eq:RT:SubBoundary Flux Total}
            L &= \dir\vdot\vec{\hat{n}} \suml[i] A(S_i)\psi_s^i\\
                    &= \dir\vdot\vec{\hat{n}} \suml[i]A(S_i)\suml[j]\frac{A(S_i\cap R_j)}{A(S_i)}\psi_r^j\\
                    &= \dir\vdot\vec{\hat{n}} \suml[i]\suml[j]A(S_i\cap R_j)\psi_r^j\\
                    &= \dir\vdot\vec{\hat{n}} \suml[j]A(R_j)\psi_r^j,
          \end{aequation}
          where this last line is simply the summation of all ray fluxes.
          The reverse problem, computing the ray fluxes from the sub-boundary fluxes, is found to be
          \begin{equation}\label{eq:RT:Ray Flux}
            \psi_r^j = \suml[i] \frac{A(S_i\cap R_j)}{A(R_j)}\psi_s^i.
          \end{equation}
          \Cref{fig:RT:2D SubBoundarySurfaceFlux} also highlights a problem with only considering the centroids of each ray.
          Ray 2 is split nearly evenly between sub-boundaries 1 and 2.
          If only the centroids are considered, all ray 2's flux would be put into sub-boundary 2.
          If the flux is relatively uniform along the surface direction, this is fine; however, if there are discontinuities in the flux then this can lead to considerable inaccuracies.

          \citet{Liu2014} introduced a useful concept to sub-boundary averaging, with the direction-dependence in the number of sub-boundaries on each surface.
          Rather than using a fixed number of sub-boundaries on each surface, it is expected that directions that are closer to being perpendicular to the surface will have larger variation, and thus need more sub-boundaries.
          The number of sub-boundaries on each surface can be computed using the dimensions of the surface, and the direction.
          Similarly to \ac{MRT}, the number of sub-boundaries on a surface is constrained to be an integer.
          The \ac{MRT} equations, \cref{eqs:MRT:Nx/y}, can be used to determine the number of sub-boundaries on the $x$ and $y$ surfaces.

          \begin{figure}
            \centering
            \def\svgwidth{0.75\linewidth}
            \input{\figpath/SubBoundarySurfaceFlux.pdf_tex}
            \caption{
              Example of sub-boundary surface flux for a single surface.
              Ray flux denoted with the $r$ subscript, and surface flux denoted with $s$ subscript.
              Ray projection areas are split by sub-boundaries in the line to the right of the impacted surface.
              \label{fig:RT:2D SubBoundarySurfaceFlux}}
          \end{figure}
        }
      }

      \subsection{Three-Dimensional Ray-Tracing Techniques}{\label{ssec:RT:Three-Dimensional Ray-Tracing Techniques}
        The \ac{MOC} is naturally extended to three-dimensional calculations along characteristic tracks spanning three-dimensions.
        However, 3-D \ac{MOC} presents significant computational challenges.
        This has led to significant research effort into developing more efficient approaches to three-dimensional \ac{MOC} \cite{Kochunas2013,Tramm2016,Yamamoto2017,Graziano2017,Gunow2017}.
        One of the main focuses of this research has been in reducing the complexity introduced by three-dimensional ray-tracing.

        \subsubsection{3-D Modular Ray-Tracing}{\label{sssec:RT:3D Modular Ray-Tracing}
          In three-dimensional \ac{MOC} calculations, characteristic rays must be laid down through the three-dimensional domain;
          Generally, three-dimensional tracks are generated by first creating a set of two-dimensional tracks, and generating three-dimensional tracks that project onto these two-dimensional tracks \cite{Kochunas2013,Shaner2015}.
          The generation of the two-dimensional tracks can be simplified as viewing each of the two-dimensional tracks as a plane in the axial and characteristic directions, $z$ and $\len$ respectively.
          Three-dimensional tracks are then produced by performing two-dimensional ray-tracing on this characteristic plane \cite{Kochunas2013}, as is shown in \cref{fig:RT:3-D Ray-tracing}

          \begin{figure}[h]
            \centering
            \def\svgwidth{0.85\linewidth}
            \input{\figpath/3D-raytracing.pdf_tex}
            \caption{3-D ray-tracing process. Generate 2-D tracks, these become characteristic planes. Along each plane, perform 2-D ray-tracing. The highlighted (red) characteristic track in the 2-D pin-cell on the left becomes the characteristic plane on the right.}
            \label{fig:RT:3-D Ray-tracing}
          \end{figure}

          There are subtleties in the generation of three-dimensional tracks, which have led to the development of different 3-D modular ray-tracing techniques \cite{Kochunas2013,Shaner2015,3DMOCCasl}.
          Previous work had reported that direct use of the \ac{MRT} method in 3-D, required that tracks be stored separately for the forward and backward directions \cite{Kochunas2013};
          this has, however, been shown not to be the case \cite{Shaner2015}.
          The simplified \ac{MRT} was developed to avoid this issue \cite{Kochunas2013}, but it generates significantly more characteristic tracks \cite{Shaner2015}.

          As discussed in \cref{ssec:RT:Modular Ray-Tracing}, 2-D \ac{MRT} perturbs the azimuthal angles in the directional quadrature to ensure \ac{DNPL}.
          For 3-D \ac{MRT}, this also perturbs the polar angles in the directional quadrature.
          \citet{Kochunas2013,3DMOCCasl} also found that modularization of the directional quadratures led to clustering of the discrete directions, which introduces significant error in the integration of spherical harmonics moments \cite{Kochunas2013}, and has implications on particle conservation in anisotropic calculations (\cref{ssec:MOC:FSA:Particle Conservation}).
          In order to avoid this issue, the axial ray-spacing can be reduced until the modularized polar angle is only perturbed within some error criteria \cite{Kochunas2013}; however, this leads to significant increases in the number of tracks (and thus increases the computational costs).
        }

        \subsubsection{Chord-Classification}{\label{sssec:RT:Chord-Classification}
          While \ac{MRT} significantly reduces the storage requirements of ray-tracing data, in realistic calculations, the data cannot fully be stored in a processors cache.
          Loading this data from main memory is slow, and in general, the movement of this ray-tracing data into different levels of cache uses significant amounts of time in these calculations.
          This led to the development of a technique called \emph{chord-classification} for locally axially extruded geometries \cite{Sciannandrone2016}.
          Chord-classification recognizes that reactors typically have regularities in the 3-D geometries; this allows for characteristic track-segments to be classified into sets which share the same length.
          As shown in \cref{fig:RT:Chord-Classification}, rays on the same characteristic plane that intersect two vertical mesh boundaries will have the same lengths.
          Similarly for rays that intersect horizontal planes (though, as axial meshes are usually tall, this is not as common).

          \begin{figure}[h]
            \centering
            \def\svgwidth{0.45\linewidth}
            \input{\figpath/ChordClassification.pdf_tex}
            \caption{3-D example of chord-classification. Colored (red and blue) characteristic tracks represent groups of ``V-chords'', rays between two vertical surfaces.}
            \label{fig:RT:Chord-Classification}
          \end{figure}

          By classifying chords of the same length, the length can be stored only once.
          Additionally, this means that the exponential functions ($F_1(\segopt)$ for \ac{FSMOC}), only need to be calculated once as well.
          This adds irregularity to the data accessing, that is generally not optimal for computation, and thus is only expected to improve calculation speeds if a large number of chords can be classified \cite{Sciannandrone2016}.
          Indeed, it was observed that most rays (96\%) could be categorized as ``V-chords'', which that intersect two vertical surfaces.
          This led to a 40\% reduction in transport sweep time \cite{Sciannandrone2016}.
          Additionally, chord-classification allows for reduced track-storage, reducing memory by up to 93\%.
        }

        \subsubsection{On-the-Fly Ray-Tracing}{\label{ssec:RT:On-the-Fly Ray-Tracing}
          The on-the-fly ray-tracing technique \cite{Gunow2016} uses some of the ideas of the chord-classification method \cite{Sciannandrone2016}, but only stores two-dimensional track information.
          All three-dimensional tracks are generated and temporarily stored during the transport sweep (on-the-fly), leading to significant memory savings (94\% reduction), with minimal computational overhead \cite{Gunow2016}.
          While leading to significant (compared to the storage of all rays) memory reduction, this approach does not see the 40\% run-time improvement that the chord-classification method has.
          It would also be a fairer comparison to compare the memory storage compared to the chord-classification method, which also showed significant improvement over traditional storage techniques.
          The chord-classification technique already boasted a 93\% reduction in track-storage memory \cite{Sciannandrone2016}; while on-the-fly ray-tracing allows for additional reduction, it is not a significant improvement over chord-classification.
        }
      }

      \subsection{Transport Sweeping with the Method of Characteristics}{\label{ssec:RT:Transport Sweeping with the Method of Characteristics}
        The \ac{MOC} is solved iteratively, each iteration is typically referred to as a \emph{transport sweep}.
        For given boundary conditions and a source, a transport sweep is used to compute estimates of the scalar flux and other moments using equations in the form \cref{eqs:MOC:FSA:Region-Averaged Flux Moments} for \ac{FSMOC} and \cref{eqs:MOC:LSA:Region-Averaged Flux Moments} for \ac{LSMOC}.
        This is an overly generalized description of a transport sweep, and there are considerations that arise from the different ray-tracing techniques discussed.

        In global ray-tracking procedures, calculations are most often carried out by examining a ray from end to end.
        The angular flux at the incident end can be found from the boundary conditions.
        Along each segment, a transmission calculation can be carried out (\cref{eqs:MOC:FSA:Angular Flux Solution,eqs:MOC:LSA:Angular Flux Solution}), and flux moments can be accumulated.
        This procedure is shared by the \ac{MRT}, which constructs global rays (long rays) by linking modular rays, as shown in \cref{fig:MRT:Modular Ray Tracing}.
        This allows for each ray calculation to be carried out in parallel, since each ray calculation is effectively independent \cite{Kochunas2013}; though special considerations must be taken to avoid race-conditions in the accumulation of moments.

        However, in the macroband method, transport sweeping is carried out in a different manner.
        It is not possible to generate a continuous characteristic track spanning the global domain when using \ac{MRMB} techniques.
        Thus, transport calculations are carried out in a pin-by-pin (assuming pins are the subsystems on which track data is generated) basis.
        For each pin calculation, boundary or interface angular fluxes can be computed as described in \cref{sssec:RT:Interface Flux Approximations}, and transmission/accumulation calculations are carried out by sweeping over the tracks.
        This can be done by considering each track separately, or by considering each ray with a macroband that is guaranteed to pass through the same regions.
        The resulting angular flux on the exiting interface must be then approximated, this can be done as described in \cref{sssec:RT:Interface Flux Approximations}.

        Pin-by-pin transport calculations must be carried out in a specific order, by considering the dependencies of the angular flux.
        \Cref{fig:RT:Macroband Sweep Order} displays the sweeping order for a $2\times2$ array of pins in 2-D; this order is significantly different than the ray-by-ray order used in traditional \ac{MRT}-based \ac{MOC} calculations.
        Sweeping in this manner limits parallelism, though it may be possible to construct a dependency graph to get an optimal sweeping order considering macrorays individually, rather than on the pin-by-pin basis; a similar idea was recently implemnted in a \ac{SN} code\cite{Adams2013}.
        The dependency graph will be different for each direction of flight \footnote{if done in a pin-by-pin manner, this can be done per octant}.

        \begin{figure}[h]
          \centering
          \def\svgwidth{0.45\linewidth}
          \input{\figpath/MacroBandSweepOrder.pdf_tex}
          \caption{Pin-by-pin sweeping order for a $2\times2$ domain with colors representing the order starting from the bottom left pin.}
          \label{fig:RT:Macroband Sweep Order}
        \end{figure}
      }
    }

    \section{Parallelism}{\label{sec:MOC:Parallelism}
        High-fidelity transport methods, such as the \ac{MOC}, can require significant computational resources for full core calculations; this is particularly true for 3-D calculations.
        While processing power has increased exponentially since the \ac{MOC} was first conceived in 1972 \cite{Askew1972}, since the early 2000's, single-core processing power has largely leveled off.
        System architectures, as well as code design, have become more focused on \emph{parallel} computations.
        Previous works \cite{Kochunas2013} made significant progress in the efficient parallelization of the \ac{MOC}.

        \citet{Kochunas2013} developed a hybrid-parallel algorithm for the \ac{MOC} that included thread-based parallelism over characteristic tracks, as well as spatial and angular decomposition.
        This work showed that the \ac{MOC} was able to scale well up to 10000's of processors.
        While this work is important, and has led to significant advancement, the use of 1000's of processors is not feasible for industrial use.
        It is the author's opinion that the primary focus of research on 3-D \ac{MOC} techniques should be on serial efficiency, such as the \acf{LSA} (\cref{ch:Improved Linear Source Formulation for Multi-physics and 2D/1D Applications}), and macroray (\cref{ch:MacroRay});
        however, moderate levels of parallelism are feasible for industry, and so more efficient use of parallel resources should also be a focus of research (\cref{ch:Spatial Decomposition}).

        In \ac{MOC} calculations, each characteristic track calculation is nearly independent from others; previous works have indicated that loops over characteristic tracks can be parallelized efficiently by using threads on traditional \acp{CPU} \cite{Kochunas2013} or on \acp{GPGPU} \cite{Boyd2014}.
        This type of parallelism is called \emph{shared-data parallelism}, as data is shared between the parallel threads.

        Large neutronics calculations may require significant amounts of memory, and thus \emph{distributed-data parallelism} is necessary.
        In general, this type of parallelism separates (partitions) a domain of the problem, and separate computing nodes are assigned a subdomain.
        Only data for the assigned subdomain is stored, and thus whole-core simulations become possible; additionally, because each subdomain can be processed in parallel, overall runtimes typically decrease with increasing numbers of subdomains (processors).

        MPACT has the capabilities for domain decomposition/parallelism over two separate domains: space and direction.
        In MPACT, each discrete direction has an easily calculable amount of work, and the decomposition is trivial; in general the same cannot be said of the spatial domain.
        As part of this thesis work, a more efficient method of spatial decomposition has been investigated and developed in MPACT \cite{Fitzgerald2019a}.
        Details on the spatial decomposition techniques used in this work are given in \cref{ch:Spatial Decomposition}.
    }

    % References
    \printbibliography
}